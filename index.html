<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spirit Well Ranch 3D Flow</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background for a futuristic feel */
            color: #e2e8f0; /* Light text color */
        }
        #info-panel {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: rgba(17, 24, 39, 0.9); /* Darker semi-transparent background */
            padding: 1rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            z-index: 100;
            max-width: 350px; /* Increased max-width for more content */
            font-size: 0.875rem;
            line-height: 1.5;
            border: 1px solid rgba(55, 65, 81, 0.5);
            display: none; /* Hidden by default */
            max-height: 90vh; /* Limit height for scrollability on small screens */
            overflow-y: auto; /* Enable scrolling for long content */
        }
        #info-panel h3 {
            font-weight: 700;
            font-size: 1.25rem; /* Slightly larger title */
            margin-bottom: 0.75rem;
            color: #93c5fd; /* Light blue for title */
        }
        #info-panel h4 {
            font-weight: 600;
            font-size: 1rem;
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
            color: #a7f3d0; /* Light green for subheadings */
        }
        #info-panel p, #info-panel ul {
            margin-bottom: 0.5rem;
        }
        #info-panel ul {
            list-style: disc;
            margin-left: 1.25rem;
            padding-left: 0;
        }
        #info-panel .close-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            color: #cbd5e1;
            font-size: 1.25rem;
            cursor: pointer;
            transition: color 0.2s;
        }
        #info-panel .close-button:hover {
            color: #f87171; /* Red on hover */
        }
        .nav-buttons-container {
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap */
            gap: 0.5rem; /* Space between buttons */
        }
        .nav-button {
            background-color: #10b981; /* Emerald green */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
            flex-grow: 1; /* Allow buttons to grow */
            min-width: 120px; /* Minimum width for buttons */
        }
        .nav-button:hover {
            background-color: #059669; /* Darker green on hover */
            transform: translateY(-1px);
        }
        .nav-button.home {
            background-color: #3b82f6; /* Blue for home button */
        }
        .nav-button.home:hover {
            background-color: #2563eb; /* Darker blue */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Mobile-specific styles for info panel */
        @media (max-width: 768px) {
            #info-panel {
                /* Remove full screen properties, let it size based on content and max-width/height */
                top: 1rem;   /* Keep top/left offset for mobile as well */
                left: 1rem;
                width: auto; /* Let content determine width */
                height: auto; /* Let content determine height */
                border-radius: 0.75rem; /* Revert to rounded corners */
                max-width: calc(100vw - 2rem); /* Constrain width to screen minus margins */
                max-height: calc(100vh - 2rem); /* Constrain height to screen minus margins */
            }
        }
    </style>
</head>
<body>
    <div id="info-panel" class="rounded-xl p-4 shadow-lg">
        <button class="close-button" onclick="hideInfoPanel();">&times;</button>
        <h3 id="info-title"></h3>
        <p id="info-description"></p>
        <div id="info-details">
            </div>
        <div id="nav-buttons" class="nav-buttons-container">
            </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script>
        // Global variables for Three.js scene
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let INTERSECTED; // To store the currently hovered object
        const nodesMap = new Map(); // Map to store Three.js objects by their data ID

        // Data structure representing the nodes and their connections
        const flowData = [
            { id: 'waste-upcycle-hub', title: 'Waste Upcycle Hub', description: 'The central sorting and routing center for all incoming waste streams, acting as the primary intake and distribution point for all materials entering the closed-loop system.',
              inputs: ['Residential & Business Recyclables (plastic, glass, metal, paper, cardboard)', 'Food Waste (BriarPatch Co-op, on-site culinary, restaurant partners)', 'Butcher Trim (fat-heavy, frozen)', 'Used Cooking Oil from local restaurants', 'Agricultural Waste (stalks, leaves, biomass)'],
              outputs: ['Streamlined inputs for downstream systems', 'Categorized byproduct data for tracking'],
              connections: ['tallow-system', 'soil-program', 'soldier-fly-farm', 'biodiesel-production', 'mushroom-cultivation', 'artist-studio'], // Added connections
              feedsInto: [{id: 'tallow-system', label: 'Tallow System'}, {id: 'soil-program', label: 'Soil Program'}, {id: 'soldier-fly-farm', label: 'Soldier Fly Farm'}, {id: 'biodiesel-production', label: 'Biodiesel Plant'}, {id: 'mushroom-cultivation', label: 'Mushroom Farm'}, {id: 'artist-studio', label: 'Art/Design Studio'}],
              type: 'core' },

            { id: 'farm-animal-program', title: 'Farm Animal Rescue & Meat', description: 'Provides ethical care for rescued farm animals (pigs, goats, poultry), integrating them into the regenerative system for feed conversion and byproduct generation.',
              inputs: ['Rescued farm animals', 'Food waste (BriarPatch, on-site) for animal feed', 'Donations and sponsorships'],
              outputs: ['Ethically sourced meat (resale)', 'Animal fats (for tallow)', 'Bones/offal', 'Manure'],
              connections: ['tallow-system', 'soil-program', 'biodiesel-production'], // Added connections
              feedsInto: [{id: 'tallow-system', label: 'Tallow System'}, {id: 'soil-program', label: 'Soil Program'}, {id: 'biodiesel-production', label: 'Biodiesel (if excess fat)'}],
              type: 'biological' },

            { id: 'soldier-fly-farm', title: 'Black Soldier Fly Farm', description: 'Converts organic waste into high-protein animal feed and organic fertilizer (frass) using black soldier fly larvae.',
              inputs: ['Food waste', 'Organic kitchen scraps', 'Cardboard mulch (bedding)', 'Byproduct tallow scraps (minimal)'],
              outputs: ['Protein-rich feed for animals', 'Frass (organic fertilizer)'],
              connections: ['farm-animal-program', 'soil-program'], // Added connections
              feedsInto: [{id: 'farm-animal-program', label: 'Animal Feed Program'}, {id: 'soil-program', label: 'Soil Program'}],
              type: 'biological' },

            { id: 'soil-program', title: 'Soil Program', description: 'The foundation of growth, creating nutrient-rich soil amendments through composting, vermiculture, and biochar activation.',
              inputs: ['Manure (animal rescue)', 'Food scraps (kitchen, BriarPatch)', 'Cardboard (from recyclables)', 'Spent mushroom substrate', 'Garden/agricultural trimmings', 'Black Soldier Fly frass', 'Biochar from pyrolysis'],
              outputs: ['Premium compost & worm castings', 'Biochar-rich soil blends', 'Mulch'],
              connections: ['herb-veg-gardens', 'mushroom-cultivation', 'soil-program'], // Added connections
              feedsInto: [{id: 'herb-veg-gardens', label: 'Herb & Vegetable Gardens'}, {id: 'mushroom-cultivation', label: 'Mushroom Substrate'}, {id: 'soil-program', label: 'Permaculture landscaping'}], // Self-referencing for landscaping
              type: 'biological' },

            { id: 'herb-veg-gardens', title: 'Herb & Vegetable Gardens', description: 'Cultivates a variety of herbs for skincare and medicine, and vegetables for culinary use, following permaculture principles.',
              inputs: ['Compost and biochar soil (from Soil Program)', 'Rainwater & greywater (future system)', 'Seeds & cuttings'],
              outputs: ['Herbs for skincare & medicine', 'Vegetables for culinary use'],
              connections: ['skincare-line', 'culinary-retreat-programs', 'soil-program'], // Added connections
              feedsInto: [{id: 'skincare-line', label: 'Skincare Line'}, {id: 'culinary-retreat-programs', label: 'Culinary & Retreat Programs'}, {id: 'soil-program', label: 'Soil Program (trimmings)'}],
              type: 'biological' },

            { id: 'mushroom-cultivation', title: 'Mushroom Cultivation', description: 'Grows gourmet mushrooms in climate-controlled environments, utilizing agricultural byproducts as substrate.',
              inputs: ['Shredded hemp stalks', 'Sawdust, cardboard, coffee grounds', 'Climate-controlled trailer (biomass heated)'],
              outputs: ['Gourmet mushrooms', 'Spent substrate for soil'],
              connections: ['culinary-retreat-programs', 'soil-program'], // Added connections
              feedsInto: [{id: 'culinary-retreat-programs', label: 'Culinary Program'}, {id: 'soil-program', label: 'Soil Program'}],
              type: 'biological' },

            { id: 'tallow-system', title: 'Tallow System', description: 'Renders animal fats into refined tallow for the skincare line and high-protein animal feed, ensuring no part of the animal goes to waste.',
              inputs: ['Butcher trim from BriarPatch (frozen fat & meat)', 'Fat from rescued animals'],
              outputs: ['Refined tallow', 'Boiled meat (high-protein animal feed)'],
              connections: ['skincare-line', 'biodiesel-production', 'farm-animal-program'], // Added connections
              feedsInto: [{id: 'skincare-line', label: 'Skincare Product Line'}, {id: 'biodiesel-production', label: 'Biodiesel System (optional secondary input)'}, {id: 'farm-animal-program', label: 'Animal Feed System'}],
              type: 'product' },

            { id: 'skincare-line', title: 'Spirit Well Skincare', description: 'Produces a line of natural, small-batch skincare products, embodying the ranch\'s regenerative ethos.',
              inputs: ['Refined tallow (from Tallow System)', 'Herbs (from on-site gardens)', 'Beeswax (future beekeeping)', 'Recycled jars/glass (from Artist Studio)'],
              outputs: ['Skincare products for sale (local, online)', 'Brand presence tied to regenerative ethos'],
              connections: ['retail-sales', 'campground-tourism'], // Added connections
              feedsInto: [{id: 'retail-sales', label: 'Retail Loop (with BriarPatch)'}, {id: 'campground-tourism', label: 'Workshops and educational demos'}],
              type: 'product' },

            { id: 'biodiesel-production', title: 'Biodiesel Production', description: 'Converts used cooking oils and excess animal fats into clean-burning biodiesel for ranch vehicles and generators.',
              inputs: ['Used cooking oil', 'Tallow (optional excess)', 'Methanol, Lye'],
              outputs: ['Biodiesel (for ranch vehicles, generators)', 'Glycerin (for soap, compost)'],
              connections: ['ranch-operations', 'soil-program'], // Added connections
              feedsInto: [{id: 'ranch-operations', label: 'Fuel for Ranch Operations'}, {id: 'soil-program', label: 'Soil Program (Glycerin)'}],
              type: 'resource' },

            { id: 'artist-studio', title: 'Artist Residency & Studio', description: 'A creative hub where local and visiting artists transform inorganic recyclables and found objects into art and functional items.',
              inputs: ['Clean metal, plastic, glass (from Recycle Hub)', 'Wood scraps, found objects', 'Local and visiting artists'],
              outputs: ['Large-scale art installations', 'Upcycled functional art', 'Circular packaging solutions'],
              connections: ['skincare-line', 'campground-tourism'], // Added connections
              feedsInto: [{id: 'skincare-line', label: 'Skincare Line (jars/branding)'}, {id: 'campground-tourism', label: 'Campground Decor / Sculpture Park'}],
              type: 'community' },

            { id: 'campground-tourism', title: 'Campground + Sculpture Park', description: 'A unique destination combining eco-cabins, outdoor exhibits, and educational events to promote regenerative tourism and community engagement.',
              inputs: ['Artist installations', 'Upcycled materials', 'Natural building elements'],
              outputs: ['Revenue from eco-tourism', 'Educational awareness', 'Community engagement'],
              connections: ['education-loop', 'artist-studio', 'fundraising'], // Added connections
              feedsInto: [{id: 'education-loop', label: 'Education Loop'}, {id: 'artist-studio', label: 'Artist Residencies'}, {id: 'fundraising', label: 'Fundraising and Grants'}],
              type: 'community' },

            // External nodes for clarity (no direct connections from them in this flow)
            { id: 'culinary-retreat-programs', title: 'Culinary & Retreat Programs', description: 'On-site culinary experiences and retreat offerings that utilize fresh produce from the gardens.', inputs: [], outputs: [], connections: [], feedsInto: [], type: 'external' },
            { id: 'retail-sales', title: 'Retail Sales', description: 'Channels for selling Spirit Well Ranch products, including local markets and online stores.', inputs: [], outputs: [], connections: [], feedsInto: [], type: 'external' },
            { id: 'ranch-operations', title: 'Ranch Operations', description: 'The daily functioning and energy consumption of the ranch, powered by sustainable energy sources like biodiesel.', inputs: [], outputs: [], connections: [], feedsInto: [], type: 'external' },
            { id: 'education-loop', title: 'Education Loop', description: 'Ongoing learning and knowledge sharing within the system, fostering a deeper understanding of regenerative practices.', inputs: [], outputs: [], connections: [], feedsInto: [], type: 'external' },
            { id: 'fundraising', title: 'Fundraising & Grants', description: 'Support mechanisms for the ranch\'s initiatives, enabling expansion and continued regenerative efforts.', inputs: [], outputs: [], connections: [], feedsInto: [], type: 'external' },
        ];

        // Mapping node types to colors (hexadecimal for Three.js)
        const nodeTypeColors = {
            'core': 0xFDE047,      // Tailwind yellow-400
            'biological': 0x6EE7B7, // Tailwind emerald-300
            'product': 0x93C5FD,   // Tailwind blue-300
            'resource': 0xFCA5A5,  // Tailwind red-300
            'community': 0xD8B4FE, // Tailwind purple-300
            'external': 0x9CA3AF   // Tailwind gray-400
        };

        // Initial camera position for "home" view
        const HOME_CAMERA_POSITION = new THREE.Vector3(0, 0, 100);
        const HOME_CONTROLS_TARGET = new THREE.Vector3(0, 0, 0);

        // Initialize the Three.js scene
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            // Load background image
            const textureLoader = new THREE.TextureLoader();
            const imagePath = './images/regeneration_background.png'; // Path to the user's image

            console.log(`Attempting to load background image from: ${imagePath}`); // Log the path being attempted

            textureLoader.load(
                imagePath,
                function(texture) {
                    scene.background = texture;
                    console.log(`Successfully loaded background image from: ${imagePath}`);
                },
                undefined, // onProgress callback
                function(err) {
                    // Log the full error object for better debugging
                    console.error(`An error occurred loading the background texture from "${imagePath}":`, err);
                    // Fallback to a reliable placeholder if the user's image fails to load
                    textureLoader.load(
                        'https://placehold.co/1920x1080/0d1117/e2e8f0?text=Regenerative+Background+Fallback',
                        function(fallbackTexture) {
                            scene.background = fallbackTexture;
                            console.log('Successfully loaded fallback background image.');
                        },
                        undefined,
                        function(fallbackErr) {
                            console.error('An error occurred loading the fallback background texture:', fallbackErr);
                            scene.background = new THREE.Color(0x0d1117); // Final fallback to solid dark color
                            console.log('Falling back to solid background color.');
                        }
                    );
                }
            );


            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(HOME_CAMERA_POSITION); // Set initial camera position

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // OrbitControls for camera interaction (drag to rotate, scroll to zoom)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth camera movement
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 20; // Prevent zooming too close
            controls.maxDistance = 200; // Prevent zooming too far
            controls.target.copy(HOME_CONTROLS_TARGET); // Set initial target

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            // Raycaster for mouse interaction (hover and click)
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Create nodes and connections
            createNodesAndConnections();

            // Event listeners for window resize, mouse interaction, and TOUCH interaction
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('click', onClick, false);
            window.addEventListener('touchend', onTouchEnd, false); // Add touch event listener for mobile devices
        }

        // Function to create a text sprite
        function createTextSprite(message, color = '#FFFFFF', fontSize = 24) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const font = `${fontSize}px Inter`; // Use Inter font
            context.font = font;

            // Measure text to set canvas size
            const metrics = context.measureText(message);
            const textWidth = metrics.width;
            const textHeight = fontSize * 1.2; // Approximate height with some padding

            canvas.width = textWidth + 10; // Add padding
            canvas.height = textHeight + 10; // Add padding

            context.font = font;
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(message, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true; // Important for dynamic textures

            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);

            // Scale sprite based on text dimensions to maintain aspect ratio
            sprite.scale.set(canvas.width * 0.1, canvas.height * 0.1, 1); // Adjust scale factor as needed

            return sprite;
        }

        // Function to create 3D nodes and connections
        function createNodesAndConnections() {
            const numNodes = flowData.length;
            const circleRadius = 60; // Radius of the circle on which nodes are placed
            const nodeSize = 3; // Size of each node sphere
            const labelOffset = nodeSize + 2; // Offset for the label above the node

            // Create nodes
            flowData.forEach((nodeData, i) => {
                // Position nodes in a circle on the X-Y plane
                const angle = (i / numNodes) * Math.PI * 2; // Distribute evenly around a circle

                const x = circleRadius * Math.cos(angle);
                const y = circleRadius * Math.sin(angle);
                const z = 0; // Keep z-coordinate constant for a flat circular arrangement

                const geometry = new THREE.SphereGeometry(nodeSize, 64, 64); // Increased segments for smoother geometry
                const material = new THREE.MeshPhongMaterial({
                    color: nodeTypeColors[nodeData.type] || 0xffffff, // Default to white if type not found
                    emissive: 0x000000, // No self-illumination initially
                    specular: 0x111111,
                    shininess: 30
                });
                const node = new THREE.Mesh(geometry, material);
                node.position.set(x, y, z);
                node.userData = { ...nodeData }; // Store all data for interaction
                scene.add(node);
                nodesMap.set(nodeData.id, node); // Store the Three.js object

                // Create and attach text label
                const labelSprite = createTextSprite(nodeData.title, '#E2E8F0', 20); // Light text color for labels
                labelSprite.position.set(x, y + labelOffset, z); // Position above the node
                scene.add(labelSprite);
            });

            // Create connections (lines)
            flowData.forEach(sourceNodeData => {
                const sourceNode = nodesMap.get(sourceNodeData.id);
                if (!sourceNode) return;

                // Ensure connections array exists and is an array before iterating
                if (sourceNodeData.connections && Array.isArray(sourceNodeData.connections)) {
                    sourceNodeData.connections.forEach(targetId => {
                        const targetNode = nodesMap.get(targetId);
                        if (!targetNode) {
                            console.warn(`Target node with ID ${targetId} not found for connection from ${sourceNodeData.id}`);
                            return;
                        }

                        const material = new THREE.LineBasicMaterial({ color: 0x34d399, linewidth: 1 }); // Emerald green line
                        const points = [];
                        points.push(sourceNode.position);
                        points.push(targetNode.position);
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(geometry, material);
                        scene.add(line);
                    });
                }
            });
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Handle mouse movement for hover effect
        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        // Internal function for click/touch logic, called by both onClick and onTouchEnd
        function onClickInternal() {
            // Only allow clicks if controls are enabled (i.e., not in the middle of a camera animation or panel is open)
            if (!controls.enabled) return; // This correctly prevents clicks on the 3D scene when controls are disabled

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {
                const clickedNode = intersects.find(obj => obj.object.userData && obj.object.userData.id);
                if (clickedNode) {
                    zoomToNode(clickedNode.object.userData.id);
                }
            }
        }

        // Handle mouse click for desktop
        function onClick(event) {
             // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            onClickInternal(); // Call the shared internal logic
        }

        // Function to handle touch end event for 'clicking' on mobile
        function onTouchEnd(event) {
            // Check if the touch originated on an element within the info panel
            const infoPanel = document.getElementById('info-panel');
            let isTouchOnPanel = false;
            let targetElement = event.target;
            while (targetElement) {
                if (targetElement === infoPanel) {
                    isTouchOnPanel = true;
                    break;
                }
                targetElement = targetElement.parentNode;
            }

            // If touch is on the panel, prevent default actions on the BODY/WINDOW
            // to allow panel's own click handlers to fire.
            // If touch is NOT on the panel, it means it's on the canvas, so preventDefault
            // to stop scrolling/zooming of the 3D scene.
            if (isTouchOnPanel) {
                // For touches on the panel, we allow normal button interaction.
                // It's generally best to avoid blanket preventDefault here.
                // Buttons' own event listeners will handle e.g., e.preventDefault() if needed.
            } else {
                // If touch is outside the panel (on the canvas), prevent default behavior
                event.preventDefault();
                event.stopPropagation(); // Also stop propagation to be safe
                // And then process the 3D scene click
                if (event.changedTouches.length > 0) {
                    const touch = event.changedTouches[0];
                    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                    onClickInternal();
                }
            }
        }


        // Function to animate camera to a target position and look at a target point
        function animateCamera(targetPosition, targetLookAt, duration = 1) {
            controls.enabled = false; // Disable controls during animation

            gsap.to(camera.position, {
                duration: duration,
                x: targetPosition.x,
                y: targetPosition.y,
                z: targetPosition.z,
                ease: "power2.inOut",
                onUpdate: function() {
                    // Update controls.target during camera movement to keep looking at the target
                    controls.target.lerp(targetLookAt, this.progress());
                    controls.update();
                },
                onComplete: function() {
                    // Only re-enable controls if the info panel is NOT currently visible
                    const infoPanel = document.getElementById('info-panel');
                    if (infoPanel.style.display !== 'block') {
                        controls.enabled = true;
                    }
                    controls.target.copy(targetLookAt); // Ensure target is exactly set
                    controls.update();
                }
            });
        }

        // Function to zoom to a specific node
        function zoomToNode(nodeId) {
            const node = nodesMap.get(nodeId);
            if (!node) {
                console.error(`Node with ID ${nodeId} not found.`);
                return;
            }

            const nodePosition = node.position;
            // Calculate a camera position slightly in front of the node
            const zoomDistance = 15; // How far the camera should be from the node
            const targetPosition = new THREE.Vector3().copy(nodePosition).add(new THREE.Vector3(0, 0, zoomDistance));

            animateCamera(targetPosition, nodePosition, 1.5); // Animate over 1.5 seconds
            displayNodeInfo(node.userData); // Display detailed info for the clicked node
        }

        // Function to zoom back to the home view
        function zoomToHome() {
            animateCamera(HOME_CAMERA_POSITION, HOME_CONTROLS_TARGET, 1.5); // Animate over 1.5 seconds
            hideInfoPanel();
        }

        // Function to display detailed node information
        function displayNodeInfo(nodeData) {
            const infoPanel = document.getElementById('info-panel');
            document.getElementById('info-title').innerText = nodeData.title;
            document.getElementById('info-description').innerText = nodeData.description;

            const infoDetails = document.getElementById('info-details');
            infoDetails.innerHTML = ''; // Clear previous details

            // Add Inputs
            if (nodeData.inputs && nodeData.inputs.length > 0) {
                const inputsTitle = document.createElement('h4');
                inputsTitle.innerText = 'Inputs:';
                infoDetails.appendChild(inputsTitle);
                const inputsList = document.createElement('ul');
                nodeData.inputs.forEach(input => {
                    const li = document.createElement('li');
                    li.innerText = input;
                    inputsList.appendChild(li);
                });
                infoDetails.appendChild(inputsList);
            }

            // Add Outputs
            if (nodeData.outputs && nodeData.outputs.length > 0) {
                const outputsTitle = document.createElement('h4');
                outputsTitle.innerText = 'Outputs:';
                infoDetails.appendChild(outputsTitle);
                const outputsList = document.createElement('ul');
                nodeData.outputs.forEach(output => {
                    const li = document.createElement('li');
                    li.innerText = output;
                    outputsList.appendChild(li);
                });
                infoDetails.appendChild(outputsList);
            }

            // Add Feeds Into / Connected Systems
            const navButtonsContainer = document.getElementById('nav-buttons');
            navButtonsContainer.innerHTML = ''; // Clear previous buttons

            // Home Button
            const homeButton = document.createElement('button');
            homeButton.className = 'nav-button home';
            homeButton.innerText = 'Zoom Out to Home';
            homeButton.addEventListener('click', zoomToHome); // For desktop clicks
            homeButton.addEventListener('touchend', (e) => { // For mobile taps
                e.preventDefault(); // Stop default touch behavior (e.g., scrolling)
                e.stopPropagation(); // Stop event from bubbling up to canvas/window
                zoomToHome();
            }, { passive: false }); // crucial for preventDefault on touch events
            navButtonsContainer.appendChild(homeButton);

            if (nodeData.feedsInto && nodeData.feedsInto.length > 0) {
                const connectedTitle = document.createElement('h4');
                connectedTitle.innerText = 'Connected Systems:';
                infoDetails.appendChild(connectedTitle); // Add title inside info-details
                // Add connected system buttons
                nodeData.feedsInto.forEach(connection => {
                    const connectedButton = document.createElement('button');
                    connectedButton.className = 'nav-button';
                    connectedButton.innerText = `Go to ${connection.label}`;
                    connectedButton.addEventListener('click', () => zoomToNode(connection.id)); // For desktop clicks
                    connectedButton.addEventListener('touchend', (e) => { // For mobile taps
                        e.preventDefault(); // Stop default touch behavior
                        e.stopPropagation(); // Stop event from bubbling up
                        zoomToNode(connection.id);
                    }, { passive: false }); // crucial for preventDefault on touch events
                    navButtonsContainer.appendChild(connectedButton);
                });
            }

            infoPanel.style.display = 'block'; // Show the info panel
            // Disable controls when panel is open
            if (controls) {
                controls.enabled = false;
            }
        }

        // Function to hide the info panel
        function hideInfoPanel() {
            const infoPanel = document.getElementById('info-panel');
            infoPanel.style.display = 'none';
            // Re-enable controls when panel is closed
            if (controls) {
                controls.enabled = true;
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update controls (only if they are enabled)
            if (controls && controls.enabled) { // Only update if controls are enabled
                controls.update();
            }

            // Raycasting for hover effect (only if controls are enabled)
            if (controls && controls.enabled) {
                // Corrected typo: setFromFromCamera -> setFromCamera
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children);

                if (intersects.length > 0) {
                    const hoveredNode = intersects.find(obj => obj.object.userData && obj.object.userData.id);

                    if (hoveredNode) {
                        if (INTERSECTED != hoveredNode.object) {
                            // Restore previous intersected object's color
                            if (INTERSECTED) {
                                INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
                            }
                            // Store current intersected object and change its color
                            INTERSECTED = hoveredNode.object;
                            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                            INTERSECTED.material.emissive.setHex(0x222222); // Subtle glow on hover
                        }
                    } else {
                        // No intersection or new object, restore previous
                        if (INTERSECTED) {
                            INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
                        }
                        INTERSECTED = null;
                    }
                } else {
                    // No intersection, restore previous
                    if (INTERSECTED) {
                        INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
                    }
                    INTERSECTED = null;
                }
            }

            renderer.render(scene, camera);
        }

        // Start the animation on window load.
        window.onload = function () {
            init();
            animate();
        };
    </script>
</body>
</html>
