<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spirit Well Ranch 3D Flow</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background for a futuristic feel */
            color: #e2e8f0; /* Light text color */
        }
        #info-panel {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: rgba(17, 24, 39, 0.9); /* Darker semi-transparent background */
            padding: 1rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            z-index: 100;
            max-width: 350px; /* Increased max-width for more content */
            font-size: 0.875rem;
            line-height: 1.5;
            border: 1px solid rgba(55, 65, 81, 0.5);
            display: none; /* Hidden by default */
            max-height: 90vh; /* Limit height for scrollability on small screens */
            overflow-y: auto; /* Enable scrolling for long content */
        }
        #info-panel h3 {
            font-weight: 700;
            font-size: 1.25rem; /* Slightly larger title */
            margin-bottom: 0.75rem;
            color: #93c5fd; /* Light blue for title */
        }
        #info-panel h4 {
            font-weight: 600;
            font-size: 1rem;
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
            color: #a7f3d0; /* Light green for subheadings */
        }
        #info-panel p, #info-panel ul {
            margin-bottom: 0.5rem;
        }
        #info-panel ul {
            list-style: disc;
            margin-left: 1.25rem;
            padding-left: 0;
        }
        #info-panel .close-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            color: #cbd5e1;
            font-size: 1.25rem;
            cursor: pointer;
            transition: color 0.2s;
        }
        #info-panel .close-button:hover {
            color: #f87171; /* Red on hover */
        }
        .nav-buttons-container {
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap */
            gap: 0.5rem; /* Space between buttons */
        }
        .nav-button {
            background-color: #10b981; /* Emerald green */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
            flex-grow: 1; /* Allow buttons to grow */
            min-width: 120px; /* Minimum width for buttons */
        }
        .nav-button:hover {
            background-color: #059669; /* Darker green on hover */
            transform: translateY(-1px);
        }
        .nav-button.home {
            background-color: #3b82f6; /* Blue for home button */
        }
        .nav-button.home:hover {
            background-color: #2563eb; /* Darker blue */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Mobile-specific styles for info panel */
        @media (max-width: 768px) {
            #info-panel {
                /* Remove full screen properties, let it size based on content and max-width/height */
                top: 1rem;   /* Keep top/left offset for mobile as well */
                left: 1rem;
                width: auto; /* Let content determine width */
                height: auto; /* Let content determine height */
                border-radius: 0.75rem; /* Revert to rounded corners */
                max-width: calc(100vw - 2rem); /* Constrain width to screen minus margins */
                max-height: calc(100vh - 2rem); /* Constrain height to screen minus margins */
            }
        }

        .overlay-button {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(59, 130, 246, 0.9); /* Tailwind blue-500 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: background-color 0.2s, transform 0.1s;
            z-index: 90; /* Below info panel but above canvas */
        }
        .overlay-button:hover {
            background-color: rgba(37, 99, 235, 0.9); /* Darker blue on hover */
            transform: translateX(-50%) translateY(-2px);
        }

        /* Adjust mobile button positioning */
        @media (max-width: 768px) {
            .overlay-button {
                bottom: 1rem; /* Slightly lower on mobile */
                font-size: 0.85rem;
                padding: 0.6rem 1rem;
                max-width: calc(100vw - 2rem); /* Prevent button from overflowing */
                white-space: normal; /* Allow text to wrap */
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div id="info-panel" class="rounded-xl p-4 shadow-lg">
        <button class="close-button" onclick="hideInfoPanel();">&times;</button>
        <h3 id="info-title"></h3>
        <p id="info-description"></p>
        <div id="info-details">
            </div>
        <div id="nav-buttons" class="nav-buttons-container">
            </div>
    </div>

    <button id="zoomOutButton" class="overlay-button">Start Experience</button>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://threejs.org/examples/js/loaders/FontLoader.js"></script>
    <script src="https://threejs.org/examples/js/geometries/TextGeometry.js"></script>
    <script>
        // Global variables for Three.js scene
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let INTERSECTED; // To store the currently hovered object
        const nodesMap = new Map(); // Map to store Three.js objects by their data ID
        const particleSystems = []; // To store particle systems for animation (for all nodes)
        let earthAtmosphereParticles; // Specific for Earth atmosphere particles
        let centralEarthSphere; // Reference to the central Earth sphere
        const laserBeams = []; // Store laser beam particle systems
        const textLabels = []; // Store 3D text labels (now Meshes) for animation

        let font; // Global variable to store the loaded font

        // Data structure representing the nodes and their connections
        const flowData = [
            { id: 'waste-upcycle-hub', title: 'Waste Upcycle Hub', description: 'The central sorting and routing center for all incoming waste streams, acting as the primary intake and distribution point for all materials entering the closed-loop system.',
              inputs: ['Residential & Business Recyclables (plastic, glass, metal, paper, cardboard)', 'Food Waste (BriarPatch Co-op, on-site culinary, restaurant partners)', 'Butcher Trim (fat-heavy, frozen)', 'Used Cooking Oil from local restaurants', 'Agricultural Waste (stalks, leaves, biomass)'],
              outputs: ['Streamlined inputs for downstream systems', 'Categorized byproduct data for tracking'],
              connections: ['tallow-system', 'soil-program', 'soldier-fly-farm', 'biodiesel-production', 'mushroom-cultivation', 'artist-studio'],
              feedsInto: [{id: 'tallow-system', label: 'Tallow System'}, {id: 'soil-program', label: 'Soil Program'}, {id: 'soldier-fly-farm', label: 'Soldier Fly Farm'}, {id: 'biodiesel-production', label: 'Biodiesel Plant'}, {id: 'mushroom-cultivation', label: 'Mushroom Farm'}, {id: 'artist-studio', label: 'Art/Design Studio'}],
              type: 'core',
              particleColor1: 0x6B7280, particleColor2: 0x9CA3AF, particleCount: 1000 // Dark grey to light grey gradient
            },

            { id: 'farm-animal-program', title: 'Farm Animal Rescue & Meat', description: 'Provides ethical care for rescued farm animals (pigs, goats, poultry), integrating them into the regenerative system for feed conversion and byproduct generation.',
              inputs: ['Rescued farm animals', 'Food waste (BriarPatch, on-site) for animal feed', 'Donations and sponsorships'],
              outputs: ['Ethically sourced meat (resale)', 'Animal fats (for tallow)', 'Bones/offal', 'Manure'],
              connections: ['tallow-system', 'soil-program', 'biodiesel-production'],
              feedsInto: [{id: 'tallow-system', label: 'Tallow System'}, {id: 'soil-program', label: 'Soil Program'}, {id: 'biodiesel-production', label: 'Biodiesel (if excess fat)'}],
              type: 'biological',
              particleColor1: 0x8B4513, particleColor2: 0xD2B48C, particleCount: 1000 // Saddle Brown to Tan gradient
            },

            { id: 'soldier-fly-farm', title: 'Black Soldier Fly Farm', description: 'Converts organic waste into high-protein animal feed and organic fertilizer (frass) using black soldier fly larvae.',
              inputs: ['Food waste', 'Organic kitchen scraps', 'Cardboard mulch (bedding)', 'Byproduct tallow scraps (minimal)'],
              outputs: ['Protein-rich feed for animals', 'Frass (organic fertilizer)'],
              connections: ['farm-animal-program', 'soil-program'],
              feedsInto: [{id: 'farm-animal-program', label: 'Animal Feed Program'}, {id: 'soil-program', label: 'Soil Program'}],
              type: 'biological',
              particleColor1: 0x556B2F, particleColor2: 0x9ACD32, particleCount: 1000 // Dark Olive Green to Yellow Green
            },

            { id: 'soil-program', title: 'Soil Program', description: 'The foundation of growth, creating nutrient-rich soil amendments through composting, vermiculture, and biochar activation.',
              inputs: ['Manure (animal rescue)', 'Food scraps (kitchen, BriarPatch)', 'Cardboard (from recyclables)', 'Spent mushroom substrate', 'Garden/agricultural trimmings', 'Black Soldier Fly frass', 'Biochar from pyrolysis'],
              outputs: ['Premium compost & worm castings', 'Biochar-rich soil blends', 'Mulch'],
              connections: ['herb-veg-gardens', 'mushroom-cultivation', 'soil-program'],
              feedsInto: [{id: 'herb-veg-gardens', label: 'Herb & Vegetable Gardens'}, {id: 'mushroom-cultivation', label: 'Mushroom Substrate'}, {id: 'soil-program', label: 'Permaculture landscaping'}],
              type: 'biological',
              particleColor1: 0x4A2C2A, particleColor2: 0x7B3F00, particleCount: 1000 // Dark Brown to Medium Brown
            },

            { id: 'herb-veg-gardens', title: 'Herb & Vegetable Gardens', description: 'Cultivates a variety of herbs for skincare and medicine, and vegetables for culinary use, following permaculture principles.',
              inputs: ['Compost and biochar soil (from Soil Program)', 'Rainwater & greywater (future system)', 'Seeds & cuttings'],
              outputs: ['Herbs for skincare & medicine', 'Vegetables for culinary use'],
              connections: ['skincare-line', 'culinary-retreat-programs', 'soil-program'],
              feedsInto: [{id: 'skincare-line', label: 'Skincare Line'}, {id: 'culinary-retreat-programs', label: 'Culinary & Retreat Programs'}, {id: 'soil-program', label: 'Soil Program (trimmings)'}],
              type: 'biological',
              particleColor1: 0x228B22, particleColor2: 0x90EE90, particleCount: 1000 // Forest Green to Light Green
            },

            { id: 'mushroom-cultivation', title: 'Mushroom Cultivation', description: 'Grows gourmet mushrooms in climate-controlled environments, utilizing agricultural byproducts as substrate.',
              inputs: ['Shredded hemp stalks', 'Sawdust, cardboard, coffee grounds', 'Climate-controlled trailer (biomass heated)'],
              outputs: ['Gourmet mushrooms', 'Spent substrate for soil'],
              connections: ['culinary-retreat-programs', 'soil-program'],
              feedsInto: [{id: 'culinary-retreat-programs', label: 'Culinary Program'}, {id: 'soil-program', label: 'Soil Program'}],
              type: 'biological',
              particleColor1: 0x8B4513, particleColor2: 0xF5DEB3, particleCount: 1000 // Saddle Brown to Wheat (mushroom cap colors)
            },

            { id: 'tallow-system', title: 'Tallow System', description: 'Renders animal fats into refined tallow for the skincare line and high-protein animal feed, ensuring no part of the animal goes to waste.',
              inputs: ['Butcher trim from BriarPatch (frozen fat & meat)', 'Fat from rescued animals'],
              outputs: ['Refined tallow', 'Boiled meat (high-protein animal feed)'],
              connections: ['skincare-line', 'biodiesel-production', 'farm-animal-program'],
              feedsInto: [{id: 'skincare-line', label: 'Skincare Product Line'}, {id: 'biodiesel-production', label: 'Biodiesel System (optional secondary input)'}, {id: 'farm-animal-program', label: 'Animal Feed System'}],
              type: 'product',
              particleColor1: 0xFFF8DC, particleColor2: 0xFFDAB9, particleCount: 1000 // Cornsilk to Peach Puff (tallow colors)
            },

            { id: 'skincare-line', title: 'Spirit Well Skincare', description: 'Produces a line of natural, small-batch skincare products, embodying the ranch\'s regenerative ethos.',
              inputs: ['Refined tallow (from Tallow System)', 'Herbs (from on-site gardens)', 'Beeswax (future beekeeping)', 'Recycled jars/glass (from Artist Studio)'],
              outputs: ['Skincare products for sale (local, online)', 'Brand presence tied to regenerative ethos'],
              connections: ['retail-sales', 'campground-tourism'],
              feedsInto: [{id: 'retail-sales', label: 'Retail Loop (with BriarPatch)'}, {id: 'campground-tourism', label: 'Workshops and educational demos'}],
              type: 'product',
              particleColor1: 0xFFC0CB, particleColor2: 0xF0F8FF, particleCount: 1000 // Pink to AliceBlue (soft skincare colors)
            },

            { id: 'biodiesel-production', title: 'Biodiesel Production', description: 'Converts used cooking oils and excess animal fats into clean-burning biodiesel for ranch vehicles and generators.',
              inputs: ['Used cooking oil', 'Tallow (optional excess)', 'Methanol, Lye'],
              outputs: ['Biodiesel (for ranch vehicles, generators)', 'Glycerin (for soap, compost)'],
              connections: ['ranch-operations', 'soil-program'],
              feedsInto: [{id: 'ranch-operations', label: 'Fuel for Ranch Operations'}, {id: 'soil-program', label: 'Soil Program (Glycerin)'}],
              type: 'resource',
              particleColor1: 0xFFD700, particleColor2: 0xFFA500, particleCount: 1200, // Gold to Orange (energetic glow)
              hasParticles: true // Add particles for extra glow
            },

            { id: 'artist-studio', title: 'Artist Residency & Studio', description: 'A creative hub where local and visiting artists transform inorganic recyclables and found objects into art and functional items.',
              inputs: ['Clean metal, plastic, glass (from Recycle Hub)', 'Wood scraps, found objects', 'Local and visiting artists'],
              outputs: ['Large-scale art installations', 'Upcycled functional art', 'Circular packaging solutions'],
              connections: ['skincare-line', 'campground-tourism'],
              feedsInto: [{id: 'skincare-line', label: 'Skincare Line (jars/branding)'}, {id: 'campground-tourism', label: 'Campground Decor / Sculpture Park'}],
              type: 'community',
              particleColor1: 0x8A2BE2, particleColor2: 0xBA55D3, particleCount: 1000 // Blue Violet to Medium Orchid (artistic colors)
            },

            { id: 'campground-tourism', title: 'Campground + Sculpture Park', description: 'A unique destination combining eco-cabins, outdoor exhibits, and educational events to promote regenerative tourism and community engagement.',
              inputs: ['Artist installations', 'Upcycled materials', 'Natural building elements'],
              outputs: ['Revenue from eco-tourism', 'Educational awareness', 'Community engagement'],
              connections: ['education-loop', 'artist-studio', 'fundraising'],
              feedsInto: [{id: 'education-loop', label: 'Education Loop'}, {id: 'artist-studio', label: 'Artist Residencies'}, {id: 'fundraising', label: 'Fundraising and Grants'}],
              type: 'community',
              particleColor1: 0x5F9EA0, particleColor2: 0xAFEEEE, particleCount: 1000 // Cadet Blue to Pale Turquoise (outdoor/nature colors)
            },

            // External nodes for clarity (no direct connections from them in this flow)
            { id: 'culinary-retreat-programs', title: 'Culinary & Retreat Programs', description: 'On-site culinary experiences and retreat offerings that utilize fresh produce from the gardens.', inputs: [], outputs: [], connections: [], feedsInto: [], type: 'external',
              particleColor1: 0xFF4500, particleColor2: 0xFFD700, particleCount: 800 // Orange Red to Gold (culinary colors)
            },
            { id: 'retail-sales', title: 'Retail Sales', description: 'Channels for selling Spirit Well Ranch products, including local markets and online stores.', inputs: [], outputs: [], connections: [], feedsInto: [], type: 'external',
              particleColor1: 0x708090, particleColor2: 0xC0C0C0, particleCount: 800 // Slate Gray to Silver (commercial/sales colors)
            },
            { id: 'ranch-operations', title: 'Ranch Operations', description: 'The daily functioning and energy consumption of the ranch, powered by sustainable energy sources like biodiesel.', inputs: [], outputs: [], connections: [], feedsInto: [], type: 'external',
              particleColor1: 0x36454F, particleColor2: 0x708090, particleCount: 800 // Charcoal to Slate Gray (operational/industrial)
            },
            { id: 'education-loop', title: 'Education Loop', description: 'Ongoing learning and knowledge sharing within the system, fostering a deeper understanding of regenerative practices.', inputs: [], outputs: [], connections: [], feedsInto: [], type: 'external',
              particleColor1: 0x4169E1, particleColor2: 0x87CEEB, particleCount: 1200 // Royal Blue to Sky Blue (knowledge/education glow)
            },
            { id: 'fundraising', title: 'Fundraising & Grants', description: 'Support mechanisms for the ranch\'s initiatives, enabling expansion and continued regenerative efforts.', inputs: [], outputs: [], connections: [], feedsInto: [], type: 'external',
              particleColor1: 0xDAA520, particleColor2: 0xFFD700, particleCount: 800 // Goldenrod to Gold (funding colors)
            },
        ];

        // Coordinates for 12450 Lime Kiln Road, Grass Valley, CA 95949
        const GRASS_VALLEY_LAT = 39.224151;
        const GRASS_VALLEY_LON = -121.036662;
        const EARTH_RADIUS_GLOBAL = 15; // Consistent Earth radius
        const EARTH_START_ZOOM_DISTANCE = 0.5; // Very close to the surface for initial view

        // Initial camera position and target for the map point (will be set after Earth creation)
        let INITIAL_MAP_CAMERA_POSITION;
        let INITIAL_MAP_CONTROLS_TARGET;

        // Define the full system view camera position and target
        const FULL_SYSTEM_VIEW_CAMERA_POSITION = new THREE.Vector3(0, 0, 100);
        const FULL_SYSTEM_VIEW_CONTROLS_TARGET = new THREE.Vector3(0, 0, 0);

        // Initialize the Three.js scene
        function init() {
            // Scene setup
            scene = new THREE.Scene();

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // OrbitControls for camera interaction (drag to rotate, scroll to zoom)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enabled = false; // Initially disabled, will be enabled by button click
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            // Raycaster for mouse interaction (hover and click)
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Load font first, then create nodes and other elements
            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (loadedFont) {
                font = loadedFont; // Assign loaded font to global variable
                console.log('Font loaded successfully!');

                // Now create everything that depends on the font
                createNodesAndConnections();
                createCentralEarthSphere();
                createUniverseSkybox();

                // Set initial camera position and target here, after all elements are created
                // (This was already handled in createCentralEarthSphere, but ensuring sequence)
                // camera.position.copy(INITIAL_MAP_CAMERA_POSITION);
                // controls.target.copy(INITIAL_MAP_CONTROLS_TARGET);
                // controls.update();

            }, undefined, function (err) {
                console.error('An error occurred loading the font:', err);
                // Fallback if font fails to load: proceed without 3D text or use simple sprites
                // For now, we'll just log the error and proceed, 3D text won't show.
                createNodesAndConnections(); // Still try to create nodes without 3D text
                createCentralEarthSphere();
                createUniverseSkybox();
            });


            // Event listeners for window resize, mouse interaction, and TOUCH interaction
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('click', onClick, false);
            window.addEventListener('touchend', onTouchEnd, false);

            // Set up the "Start Experience" button
            const zoomOutButton = document.getElementById('zoomOutButton');
            zoomOutButton.innerText = 'Click Here to start the Spirit Well Ranch Circular Systems';
            zoomOutButton.style.display = 'block';

            zoomOutButton.addEventListener('click', () => {
                zoomToFullSystemView();
                zoomOutButton.style.display = 'none';
            });
            zoomOutButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                zoomToFullSystemView();
                zoomOutButton.style.display = 'none';
            }, { passive: false });
        }

        // Function to convert Lat/Lon to Three.js Cartesian coordinates (Y-up)
        function latLonToCartesian(lat, lon, radius) {
            const latRad = lat * (Math.PI / 180);
            const lonRad = -lon * (Math.PI / 180);

            const x = radius * Math.cos(latRad) * Math.sin(lonRad);
            const y = radius * Math.sin(latRad);
            const z = radius * Math.cos(latRad) * Math.cos(lonRad);

            return new THREE.Vector3(x, y, z);
        }

        // Function to create 3D text label
        function create3DTextLabel(message, color = 0x00FFFF, fontSize = 5, nodeRadius) {
            if (!font) {
                console.warn("Font not loaded, cannot create 3D text label.");
                // Fallback to a simple sprite if font isn't loaded
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256; canvas.height = 64;
                context.font = 'bold 30px Inter';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(message, canvas.width / 2, canvas.height / 2);
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture, color: 0xFFFFFF, transparent: true, blending: THREE.AdditiveBlending });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(nodeRadius * 2, nodeRadius * 0.5, 1); // Approximate scale
                return sprite;
            }

            const textGeometry = new THREE.TextGeometry(message, {
                font: font,
                size: fontSize, // Use provided font size
                height: 0.1, // Thickness of the text
                curveSegments: 12,
                bevelEnabled: false
            });

            textGeometry.computeBoundingBox();
            // Center the text by translating its geometry
            textGeometry.translate(
                -(textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x) / 2,
                -(textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y) / 2,
                -(textGeometry.boundingBox.max.z - textGeometry.boundingBox.min.z) / 2
            );

            const textMaterial = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });

            const textMesh = new THREE.Mesh(textGeometry, textMaterial);

            // Store original emissive color for hover effect
            textMesh.userData.originalEmissive = textMaterial.emissive.getHex();
            textMesh.userData.isTextLabel = true;

            textLabels.push(textMesh);

            return textMesh;
        }


        // Vertex Shader for Particle Nodes (with blinking/pulsing)
        const particleNodeVertexShader = `
            attribute float blinkOffset;
            attribute vec3 color; // Per-particle color
            uniform float uTime;
            uniform float uPointSize;
            uniform float uNodeRadius;
            uniform vec3 uColor1; // Base color 1 from JS
            uniform vec3 uColor2; // Base color 2 from JS

            varying float vAlpha;
            varying vec3 vColor;

            void main() {
                // Calculate position along the node's radius for color gradient
                float distFromCenter = length(position.xyz);
                float alphaGradient = distFromCenter / uNodeRadius;
                vColor = mix(uColor1, uColor2, alphaGradient); // Interpolate color

                // Firefly blinking/pulsating effect
                float blinkFactor = sin(uTime * 5.0 + blinkOffset); // Faster blink
                float opacity = clamp(blinkFactor * 1.0 + 0.5, 0.0, 1.0); // Pulsate opacity
                float size = uPointSize * (1.0 + blinkFactor * 0.5); // Pulsate size

                vAlpha = opacity;

                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * (1.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        // Fragment Shader for Particle Nodes
        const particleNodeFragmentShader = `
            varying float vAlpha;
            varying vec3 vColor;

            void main() {
                float r = 0.0;
                vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                r = dot(cxy, cxy);
                float alpha = smoothstep(1.0, 0.0, r) * vAlpha; // Circular fade

                gl_FragColor = vec4(vColor, alpha);
                if (gl_FragColor.a < 0.0001) discard;
            }
        `;

        // Vertex Shader for Atmosphere Particles (with blinking/pulsing)
        const atmosphereVertexShader = `
            attribute float blinkOffset;
            attribute vec3 color; // Per-particle color
            uniform float uTime;
            uniform float uPointSize;

            varying float vAlpha;
            varying vec3 vColor;

            void main() {
                vColor = color; // Pass color to fragment shader

                // Firefly blinking/pulsating effect
                float blinkFactor = sin(uTime * 4.0 + blinkOffset); // Slightly different blink speed
                float opacity = clamp(blinkFactor * 1.0 + 0.5, 0.0, 1.0);
                float size = uPointSize * (1.0 + blinkFactor * 0.5);

                vAlpha = opacity;

                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * (1.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        // Fragment Shader for Atmosphere Particles (same as node fragment shader)
        const atmosphereFragmentShader = `
            varying float vAlpha;
            varying vec3 vColor;

            void main() {
                float r = 0.0;
                vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                r = dot(cxy, cxy);
                float alpha = smoothstep(1.0, 0.0, r) * vAlpha;

                gl_FragColor = vec4(vColor, alpha);
                if (gl_FragColor.a < 0.0001) discard;
            }
        `;

        // Function to create a dense gradient particle system for a node
        function createParticleNode(nodeData, position) {
            const particleCount = nodeData.particleCount || 1000; // Default particle count
            const innerParticleRadius = 2.5; // Radius of the inner particle cloud
            const outerSphereRadius = 3.5; // Radius of the outer translucent sphere
            const sphereSegments = 32; // For the outer sphere

            // --- Create the INNER Particle System ---
            const particlesGeometry = new THREE.BufferGeometry();
            const positions = [];
            const blinkOffsets = []; // For firefly effect

            for (let i = 0; i < particleCount; i++) {
                const r = innerParticleRadius * Math.cbrt(Math.random()); // Distribute more evenly within volume
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                positions.push(x, y, z);
                blinkOffsets.push(Math.random() * Math.PI * 2);
            }

            particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('blinkOffset', new THREE.Float32BufferAttribute(blinkOffsets, 1));

            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0.0 },
                    uPointSize: { value: 0.05 }, // Very tiny dots
                    uNodeRadius: { value: innerParticleRadius },
                    uColor1: { value: new THREE.Color(nodeData.particleColor1) },
                    uColor2: { value: new THREE.Color(nodeData.particleColor2) }
                },
                vertexShader: particleNodeVertexShader,
                fragmentShader: particleNodeFragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const particleSystem = new THREE.Points(particlesGeometry, particleMaterial);
            // particleSystem.position is relative to its parent (the outer sphere)
            particleSystems.push(particleSystem); // Add to general particle systems for animation

            // --- Create the OUTER Translucent Sphere (the clickable part) ---
            const outerSphereGeometry = new THREE.SphereGeometry(outerSphereRadius, sphereSegments, sphereSegments);
            const outerSphereMaterial = new THREE.MeshPhongMaterial({
                color: nodeData.particleColor1, // Base color for the outer sphere
                emissive: nodeData.particleColor1, // Emissive color for glow
                emissiveIntensity: 0.1, // Subtle glow
                transparent: true,
                opacity: 0.4, // Increased opacity for the glass sphere
                shininess: 50,
                specular: 0x555555
            });
            const outerSphere = new THREE.Mesh(outerSphereGeometry, outerSphereMaterial);
            outerSphere.position.copy(position); // Set the position of the outer sphere

            // Make the particle system a child of the outer sphere
            outerSphere.add(particleSystem);

            // Store the outer sphere as the main interactive node
            outerSphere.userData = { ...nodeData, isParticleNode: true, originalEmissive: outerSphereMaterial.emissive.getHex() };
            scene.add(outerSphere);
            nodesMap.set(nodeData.id, outerSphere);

            return outerSphere; // Return the outer sphere as the main node object
        }

        // Function to create a laser beam particle system between two nodes
        function createLaserBeam(sourceNode, targetNode) {
            const path = new THREE.Line3(sourceNode.position, targetNode.position);
            const length = path.distance();
            const particleCount = Math.floor(length * 20); // Denser particles for longer beams
            const particlesGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const alphas = new Float32Array(particleCount); // For pulsing effect
            const offsets = new Float32Array(particleCount); // Unique offset for each particle
            const speeds = new Float32Array(particleCount); // Speeds for each particle

            // Get colors from source/target nodes' particleColor1
            const sourceColor = new THREE.Color(sourceNode.userData.particleColor1 || 0x00FFFF); // Default cyan
            const targetColor = new THREE.Color(targetNode.userData.particleColor1 || 0x00FFFF); // Default cyan

            const colors = new Float32Array(particleCount * 3); // For gradient color

            for (let i = 0; i < particleCount; i++) {
                const t = i / (particleCount - 1); // Normalized position along the line (0 to 1)

                // Initial position along the line
                const point = new THREE.Vector3().lerpVectors(sourceNode.position, targetNode.position, t);
                positions[i * 3] = point.x;
                positions[i * 3 + 1] = point.y;
                positions[i * 3 + 2] = point.z;

                alphas[i] = Math.random(); // Random initial opacity
                offsets[i] = Math.random() * Math.PI * 2; // Random animation offset
                speeds[i] = Math.random() * 0.5 + 0.5; // Random speed for varied pulsing (0.5 to 1.0)

                // Calculate gradient color
                const mixedColor = new THREE.Color().copy(sourceColor).lerp(targetColor, t);
                colors[i * 3] = mixedColor.r;
                colors[i * 3 + 1] = mixedColor.g;
                colors[i * 3 + 2] = mixedColor.b;
            }

            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
            particlesGeometry.setAttribute('offset', new THREE.BufferAttribute(offsets, 1));
            particlesGeometry.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const laserVertexShader = `
                attribute float alpha;
                attribute float offset;
                attribute vec3 color;
                attribute float speed;
                uniform float uTime;
                uniform float uPointSize;
                uniform float uTravelSpeed;
                uniform float uPulseSpeed;
                uniform vec3 uSourcePos;
                uniform vec3 uTargetPos;

                varying float vAlpha;
                varying vec3 vColor;

                void main() {
                    vColor = color;

                    float t = length(position.xyz - uSourcePos) / length(uTargetPos - uSourcePos);
                    t = clamp(t, 0.0, 1.0);

                    float travelProgress = fract(uTime * uTravelSpeed * speed + offset);
                    float currentT = fract(t + travelProgress);

                    vec3 animatedPosition = mix(uSourcePos, uTargetPos, currentT);

                    float pulseFactor = sin(currentT * uPulseSpeed * 3.14159 * 2.0 + uTime * 2.0);
                    float size = uPointSize * (1.0 + pulseFactor * 0.5);
                    float opacity = clamp(pulseFactor * 1.5 + 0.5, 0.0, 1.0);

                    vAlpha = opacity * alpha;

                    vec4 mvPosition = modelViewMatrix * vec4(animatedPosition, 1.0);
                    gl_PointSize = size * (1.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;

            const laserFragmentShader = `
                varying float vAlpha;
                varying vec3 vColor;

                void main() {
                    float r = 0.0;
                    vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                    r = dot(cxy, cxy);
                    float alpha = smoothstep(1.0, 0.0, r) * vAlpha;

                    gl_FragColor = vec4(vColor, alpha);
                    if (gl_FragColor.a < 0.0001) discard;
                }
            `;

            const laserMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0.0 },
                    uPointSize: { value: 1.0 }, // Base particle size for laser
                    uTravelSpeed: { value: 0.1 }, // Speed of particles traveling along beam
                    uPulseSpeed: { value: 1.0 }, // Speed of the pulse itself
                    uSourcePos: { value: sourceNode.position },
                    uTargetPos: { value: targetNode.position },
                    uColor1: { value: sourceColor },
                    uColor2: { value: targetColor }
                },
                vertexShader: laserVertexShader,
                fragmentShader: laserFragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const laserBeam = new THREE.Points(particlesGeometry, laserMaterial);
            laserBeam.userData.animationOffset = Math.random();
            laserBeams.push(laserBeam);
            scene.add(laserBeam);
            return laserBeam;
        }


        // Function to create the central Earth sphere with particles
        function createCentralEarthSphere() {
            const earthRadius = EARTH_RADIUS_GLOBAL;
            const earthSegments = 64;

            const earthGeometry = new THREE.SphereGeometry(earthRadius, earthSegments, earthSegments);
            const textureLoader = new THREE.TextureLoader();

            textureLoader.load(
                'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg',
                function(earthTexture) {
                    const earthMaterial = new THREE.MeshPhongMaterial({
                        map: earthTexture,
                        specular: 0x333333,
                        shininess: 15
                    });
                    centralEarthSphere = new THREE.Mesh(earthGeometry, earthMaterial);
                    centralEarthSphere.position.set(0, 0, 0);
                    scene.add(centralEarthSphere);

                    // Add atmospheric particles around Earth
                    const atmosphereParticleCount = 2000; // Increased count
                    const atmosphereParticlesGeometry = new THREE.BufferGeometry();
                    const atmospherePositions = [];
                    const atmosphereColors = []; // For multicolor firefly
                    const atmosphereBlinkOffsets = []; // For firefly effect

                    for (let i = 0; i < atmosphereParticleCount; i++) {
                        const radiusOffset = earthRadius + (Math.random() * 5);
                        const phi = Math.acos(Math.random() * 2 - 1); // Distribute more evenly
                        const theta = Math.random() * Math.PI * 2;

                        const x = radiusOffset * Math.sin(phi) * Math.cos(theta);
                        const y = radiusOffset * Math.sin(phi) * Math.sin(theta);
                        const z = radiusOffset * Math.cos(phi);
                        atmospherePositions.push(x, y, z);

                        // Multicolor firefly effect: broader HSL range
                        const color = new THREE.Color();
                        color.setHSL(Math.random(), 0.5 + Math.random() * 0.5, 0.7 + Math.random() * 0.3); // Broader hue range
                        atmosphereColors.push(color.r, color.g, color.b);
                        atmosphereBlinkOffsets.push(Math.random() * Math.PI * 2);
                    }

                    atmosphereParticlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(atmospherePositions, 3));
                    atmosphereParticlesGeometry.setAttribute('color', new THREE.Float32BufferAttribute(atmosphereColors, 3));
                    atmosphereParticlesGeometry.setAttribute('blinkOffset', new THREE.Float32BufferAttribute(atmosphereBlinkOffsets, 1)); // Add blink offset

                    const atmosphereMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            uTime: { value: 0.0 },
                            uPointSize: { value: 0.1 } // Tiny dots for atmosphere
                        },
                        vertexShader: atmosphereVertexShader, // Use the defined shader
                        fragmentShader: atmosphereFragmentShader, // Use the defined shader
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false // Important for transparent particles
                    });

                    earthAtmosphereParticles = new THREE.Points(atmosphereParticlesGeometry, atmosphereMaterial);
                    scene.add(earthAtmosphereParticles);

                    // --- Set Initial Camera Position After Earth is Loaded ---
                    const mapPointOnEarth = latLonToCartesian(GRASS_VALLEY_LAT, GRASS_VALLEY_LON, earthRadius);
                    INITIAL_MAP_CAMERA_POSITION = mapPointOnEarth.clone().normalize().multiplyScalar(earthRadius + EARTH_START_ZOOM_DISTANCE);
                    INITIAL_MAP_CONTROLS_TARGET = mapPointOnEarth.clone();

                    camera.position.copy(INITIAL_MAP_CAMERA_POSITION);
                    controls.target.copy(INITIAL_MAP_CONTROLS_TARGET);
                    controls.minDistance = earthRadius + 0.1;
                    controls.maxDistance = 200;
                    controls.update();
                },
                undefined,
                function(err) {
                    console.error('An error occurred loading the Earth texture:', err);
                    const fallbackMaterial = new THREE.MeshPhongMaterial({ color: 0x0000FF });
                    centralEarthSphere = new THREE.Mesh(earthGeometry, fallbackMaterial);
                    centralEarthSphere.position.set(0, 0, 0);
                    scene.add(centralEarthSphere);

                    const mapPointOnEarth = latLonToCartesian(GRASS_VALLEY_LAT, GRASS_VALLEY_LON, earthRadius);
                    INITIAL_MAP_CAMERA_POSITION = mapPointOnEarth.clone().normalize().multiplyScalar(earthRadius + EARTH_START_ZOOM_DISTANCE);
                    INITIAL_MAP_CONTROLS_TARGET = mapPointOnEarth.clone();

                    camera.position.copy(INITIAL_MAP_CAMERA_POSITION);
                    controls.target.copy(INITIAL_MAP_CONTROLS_TARGET);
                    controls.minDistance = earthRadius + 0.1;
                    controls.maxDistance = 200;
                    controls.update();
                }
            );
        }

        // Function to create the universe skybox using a Milky Way texture
        function createUniverseSkybox() {
            const skyboxGeometry = new THREE.SphereGeometry(500, 32, 32);
            const textureLoader = new THREE.TextureLoader();

            const milkyWayTexturePath = 'https://cdn.jsdelivr.net/gh/jeromeetienne/threex.planets@master/images/galaxy_starfield.png';

            textureLoader.load(
                milkyWayTexturePath,
                function(texture) {
                    const skyboxMaterial = new THREE.MeshBasicMaterial({
                        map: texture,
                        side: THREE.BackSide
                    });
                    const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
                    scene.add(skybox);
                    console.log(`Successfully loaded Milky Way skybox from: ${milkyWayTexturePath}`);
                },
                undefined,
                function(err) {
                    console.error(`An error occurred loading the Milky Way texture from "${milkyWayTexturePath}":`, err);
                    const fallbackMaterial = new THREE.MeshBasicMaterial({ color: 0x000033, side: THREE.BackSide });
                    const skybox = new THREE.Mesh(skyboxGeometry, fallbackMaterial);
                    scene.add(skybox);
                    console.log('Falling back to solid dark blue skybox.');
                }
            );
        }

        // Function to create 3D nodes and connections
        function createNodesAndConnections() {
            const numNodes = flowData.length;
            const orbitRadius = 60;
            const nodeSize = 3;
            const labelVerticalOffset = nodeSize * 2.5; // Vertical offset for the label above the node

            flowData.forEach((nodeData, i) => {
                const phi = Math.acos(1 - (2 * (i + 0.5)) / numNodes);
                const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);

                const x = orbitRadius * Math.cos(theta) * Math.sin(phi);
                const y = orbitRadius * Math.sin(theta) * Math.sin(phi);
                const z = orbitRadius * Math.cos(phi);

                const node = createParticleNode(nodeData, new THREE.Vector3(x, y, z));

                // Create and attach 3D text label
                const labelMesh = create3DTextLabel(nodeData.title, 0x00FFFF, 1.0, nodeSize); // Cyan color, font size 1.0 (1/3 smaller)
                // Position the label relative to the node
                labelMesh.position.set(0, labelVerticalOffset, 0); // Above the sphere
                node.add(labelMesh); // Make label a child of the node

                // Create and attach the post
                const postMesh = createSignPost(nodeSize, labelVerticalOffset);
                node.add(postMesh); // Make post a child of the node

                node.userData.labelMesh = labelMesh; // Store reference to the label for potential interaction
            });

            flowData.forEach(sourceNodeData => {
                const sourceNode = nodesMap.get(sourceNodeData.id);
                if (!sourceNode) return;

                if (sourceNodeData.connections && Array.isArray(sourceNodeData.connections)) {
                    sourceNodeData.connections.forEach(targetId => {
                        const targetNode = nodesMap.get(targetId);
                        if (!targetNode) {
                            console.warn(`Target node with ID ${targetId} not found for connection from ${sourceNodeData.id}`);
                            return;
                        }
                        createLaserBeam(sourceNode, targetNode);
                    });
                }
            });
        }

        // Function to create a wood-like sign (Removed as per user request)
        // function createWoodSign(message, nodeSize) { /* ... */ }

        // Function to create a post for the sign
        function createSignPost(nodeSize, signVerticalOffset) {
            const postRadius = 0.2;
            // Height from top of sphere to the bottom of the sign
            // signVerticalOffset is center of sign, so subtract half sign height
            const signHeightWorld = nodeSize * 1.5; // Approximate sign height in world units
            const postHeight = signVerticalOffset - (signHeightWorld / 2) - (nodeSize * 0.8); // Adjusted to go into the sphere slightly
            const postGeometry = new THREE.CylinderGeometry(postRadius, postRadius, postHeight, 8);
            const postMaterial = new THREE.MeshPhongMaterial({ color: 0x5C4033 }); // Dark brown color

            const postMesh = new THREE.Mesh(postGeometry, postMaterial);
            // Position the post to connect the top of the sphere to the bottom of the sign
            postMesh.position.set(0, (signVerticalOffset / 2) - (signHeightWorld / 4) - (nodeSize * 0.4), 0); // Adjusted to go into the sphere
            return postMesh;
        }


        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Handle mouse movement for hover effect
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        // Internal function for click/touch logic, called by both onClick and onTouchEnd
        function onClickInternal() {
            if (!controls.enabled) return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                // Filter for actual interactive nodes (outer spheres or Earth)
                const clickedObject = intersects.find(obj =>
                    obj.object.userData && obj.object.userData.id &&
                    (obj.object.userData.isParticleNode || obj.object === centralEarthSphere || obj.object.userData.isTextLabel) // Also check for text labels
                );

                if (clickedObject) {
                    if (clickedObject.object === centralEarthSphere) {
                        console.log("Clicked Earth Sphere!");
                    } else if (clickedObject.object.userData.isParticleNode) {
                        zoomToNode(clickedObject.object.userData.id);
                    } else if (clickedObject.object.userData.isTextLabel) { // If a text label is clicked
                        // Find the parent node (outer sphere)
                        let parentNode = clickedObject.object.parent;
                        while (parentNode && (!parentNode.userData || !parentNode.userData.isParticleNode)) {
                            parentNode = parentNode.parent;
                        }
                        if (parentNode) {
                            zoomToNode(parentNode.userData.id);
                        }
                    }
                }
            }
        }

        // Handle mouse click for desktop
        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            onClickInternal();
        }

        // Function to handle touch end event for 'clicking' on mobile
        function onTouchEnd(event) {
            const infoPanel = document.getElementById('info-panel');
            const zoomOutButton = document.getElementById('zoomOutButton');

            let isTouchOnUI = false;
            let targetElement = event.target;
            while (targetElement) {
                if (targetElement === infoPanel || targetElement === zoomOutButton) {
                    isTouchOnUI = true;
                    break;
                }
                targetElement = targetElement.parentNode;
            }

            if (isTouchOnUI) {
                return;
            } else {
                event.preventDefault();
                event.stopPropagation();
                if (event.changedTouches.length > 0) {
                    const touch = event.changedTouches[0];
                    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                    onClickInternal();
                }
            }
        }

        // Function to animate camera to a target position and look at a target point
        function animateCamera(targetPosition, targetLookAt, duration = 1) {
            controls.enabled = false;

            gsap.to(camera.position, {
                duration: duration,
                x: targetPosition.x,
                y: targetPosition.y,
                z: targetPosition.z,
                ease: "power2.inOut",
                onUpdate: function() {
                    controls.target.lerp(targetLookAt, this.progress());
                    controls.update();
                },
                onComplete: function() {
                    const infoPanel = document.getElementById('info-panel');
                    if (infoPanel.style.display !== 'block') {
                        controls.enabled = true;
                    }
                    controls.target.copy(targetLookAt);
                    controls.update();
                }
            });
        }

        // Function to zoom to a specific node (now a particle system)
        function zoomToNode(nodeId) {
            const node = nodesMap.get(nodeId);
            if (!node) {
                console.error(`Node with ID ${nodeId} not found.`);
                return;
            }

            const nodePosition = node.position;
            const zoomDistance = 15;
            const targetPosition = new THREE.Vector3().copy(nodePosition).add(new THREE.Vector3(0, 0, zoomDistance));

            animateCamera(targetPosition, nodePosition, 1.5);
            displayNodeInfo(node.userData);
        }

        // Function to zoom to the full system view
        function zoomToFullSystemView() {
            animateCamera(FULL_SYSTEM_VIEW_CAMERA_POSITION, FULL_SYSTEM_VIEW_CONTROLS_TARGET, 2);
            hideInfoPanel();
        }

        // Function to display detailed node information
        function displayNodeInfo(nodeData) {
            const infoPanel = document.getElementById('info-panel');
            document.getElementById('info-title').innerText = nodeData.title;
            document.getElementById('info-description').innerText = nodeData.description;

            const infoDetails = document.getElementById('info-details');
            infoDetails.innerHTML = '';

            // Highlight relevant laser beams
            laserBeams.forEach(beam => {
                // Ensure userData and its properties exist before accessing
                const sourceId = beam.userData.sourceNode ? beam.userData.sourceNode.userData.id : null;
                const targetId = beam.userData.targetNode ? beam.userData.targetNode.userData.id : null;
                const isConnected = (sourceId === nodeData.id || targetId === nodeData.id);

                if (isConnected) {
                    beam.material.uniforms.uColor1.value.setHex(0x00FF00); // Bright green for connected
                    beam.material.uniforms.uColor2.value.setHex(0x00FF00);
                    beam.material.uniforms.uPulseSpeed.value = 2.0; // Faster pulse
                    beam.material.uniforms.uTravelSpeed.value = 0.2; // Faster travel
                } else {
                    beam.material.uniforms.uColor1.value.setHex(0x101010); // Dim for non-connected
                    beam.material.uniforms.uColor2.value.setHex(0x101010);
                    beam.material.uniforms.uPulseSpeed.value = 0.5; // Slower pulse
                    beam.material.uniforms.uTravelSpeed.value = 0.05; // Slower travel
                }
            });


            if (nodeData.inputs && nodeData.inputs.length > 0) {
                const inputsTitle = document.createElement('h4');
                inputsTitle.innerText = 'Inputs:';
                infoDetails.appendChild(inputsTitle);
                const inputsList = document.createElement('ul');
                nodeData.inputs.forEach(input => {
                    const li = document.createElement('li');
                    li.innerText = input;
                    inputsList.appendChild(li);
                });
                infoDetails.appendChild(inputsList);
            }

            if (nodeData.outputs && nodeData.outputs.length > 0) {
                const outputsTitle = document.createElement('h4');
                outputsTitle.innerText = 'Outputs:';
                infoDetails.appendChild(outputsTitle);
                const outputsList = document.createElement('ul');
                nodeData.outputs.forEach(output => {
                    const li = document.createElement('li');
                    li.innerText = output;
                    outputsList.appendChild(li);
                });
                infoDetails.appendChild(outputsList);
            }

            const navButtonsContainer = document.getElementById('nav-buttons');
            navButtonsContainer.innerHTML = '';

            const homeButton = document.createElement('button');
            homeButton.className = 'nav-button home';
            homeButton.innerText = 'Zoom Out to Home';
            homeButton.addEventListener('click', zoomToFullSystemView);
            homeButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                zoomToFullSystemView();
            }, { passive: false });
            navButtonsContainer.appendChild(homeButton);

            if (nodeData.feedsInto && nodeData.feedsInto.length > 0) {
                const connectedTitle = document.createElement('h4');
                connectedTitle.innerText = 'Connected Systems:';
                infoDetails.appendChild(connectedTitle);
                nodeData.feedsInto.forEach(connection => {
                    const connectedButton = document.createElement('button');
                    connectedButton.className = 'nav-button';
                    connectedButton.innerText = `Go to ${connection.label}`;
                    connectedButton.addEventListener('click', () => zoomToNode(connection.id));
                    connectedButton.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        zoomToNode(connection.id);
                    }, { passive: false });
                    navButtonsContainer.appendChild(connectedButton);
                });
            }

            infoPanel.style.display = 'block';
            if (controls) {
                controls.enabled = false;
            }
        }

        // Function to hide the info panel
        function hideInfoPanel() {
            const infoPanel = document.getElementById('info-panel');
            infoPanel.style.display = 'none';

            // Reset laser beam colors to original
            laserBeams.forEach(beam => {
                // Ensure userData and its properties exist before accessing
                const sourceNodeData = beam.userData.sourceNode ? beam.userData.sourceNode.userData : null;
                const targetNodeData = beam.userData.targetNode ? beam.userData.targetNode.userData : null;

                if (sourceNodeData && targetNodeData) {
                    const originalSourceColor = new THREE.Color(sourceNodeData.particleColor1 || 0x00FFFF);
                    const originalTargetColor = new THREE.Color(targetNodeData.particleColor1 || 0x00FFFF);
                    beam.material.uniforms.uColor1.value.copy(originalSourceColor);
                    beam.material.uniforms.uColor2.value.copy(originalTargetColor);
                    beam.material.uniforms.uPulseSpeed.value = 1.0; // Reset to default pulse speed
                    beam.material.uniforms.uTravelSpeed.value = 0.1; // Reset to default travel speed
                } else {
                    console.warn("Missing source/target node data for beam reset:", beam);
                }
            });

            if (controls) {
                controls.enabled = true;
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update controls (only if they are enabled)
            if (controls && controls.enabled) {
                controls.update();
            }

            // Animate particles for the central Earth atmosphere
            if (earthAtmosphereParticles && earthAtmosphereParticles.material.uniforms) {
                earthAtmosphereParticles.material.uniforms.uTime.value += 0.01;
                earthAtmosphereParticles.rotation.y += 0.001; // Slow rotation
            }

            // Animate each particle system node (nodes that are particle clouds)
            particleSystems.forEach(ps => {
                // Update uniform for shader animation
                if (ps.material.uniforms && ps.material.uniforms.uTime) {
                    ps.material.uniforms.uTime.value += 0.01;
                }
                // Subtle rotation for the particle cloud as a whole
                ps.rotation.y += 0.002;
                ps.rotation.x += 0.001;
            });

            // Animate laser beams
            laserBeams.forEach(beam => {
                // Update uniform for shader animation
                if (beam.material.uniforms && beam.material.uniforms.uTime) {
                    beam.material.uniforms.uTime.value += 0.01;
                }
            });

            // Animate text labels (3D meshes)
            textLabels.forEach(label => {
                // Make the 3D text always face the camera
                label.lookAt(camera.position);
            });


            // Raycasting for hover effect (only if controls are enabled)
            if (controls && controls.enabled) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children, true);

                if (intersects.length > 0) {
                    // Filter for actual interactive nodes (outer spheres or Earth)
                    const hoveredObject = intersects.find(obj =>
                        obj.object.userData && obj.object.userData.id &&
                        (obj.object.userData.isParticleNode || obj.object === centralEarthSphere || obj.object.userData.isTextLabel) // Also check for text labels
                    );

                    if (hoveredObject) {
                        if (INTERSECTED != hoveredObject.object) {
                            if (INTERSECTED) {
                                // Reset previous hovered object's emissive color
                                if (INTERSECTED.material && INTERSECTED.material.emissive) {
                                    INTERSECTED.material.emissive.setHex(INTERSECTED.currentEmissiveHex);
                                }
                                // Reset text label color if it was the previously hovered object
                                if (INTERSECTED.userData.isTextLabel && INTERSECTED.material && INTERSECTED.material.emissive) {
                                     INTERSECTED.material.emissive.setHex(INTERSECTED.userData.originalEmissive);
                                }
                            }
                            // Store current hovered object and change its emissive color
                            INTERSECTED = hoveredObject.object;
                            if (INTERSECTED.material && INTERSECTED.material.emissive) {
                                INTERSECTED.currentEmissiveHex = INTERSECTED.material.emissive.getHex(); // Store current emissive
                                INTERSECTED.material.emissive.setHex(0x00FF00); // Green glow on hover
                            }
                        }
                    } else {
                        // No interactive object intersected, restore previous
                        if (INTERSECTED) {
                            if (INTERSECTED.material && INTERSECTED.material.emissive) {
                                INTERSECTED.material.emissive.setHex(INTERSECTED.currentEmissiveHex);
                            }
                            // Reset text label color if it was the previously hovered object
                            if (INTERSECTED.userData.isTextLabel && INTERSECTED.material && INTERSECTED.material.emissive) {
                                 INTERSECTED.material.emissive.setHex(INTERSECTED.userData.originalEmissive);
                            }
                        }
                        INTERSECTED = null;
                    }
                } else {
                    // No intersection at all, restore previous
                    if (INTERSECTED) {
                        if (INTERSECTED.material && INTERSECTED.material.emissive) {
                            INTERSECTED.material.emissive.setHex(INTERSECTED.currentEmissiveHex);
                        }
                        // Reset text label color if it was the previously hovered object
                        if (INTERSECTED.userData.isTextLabel && INTERSECTED.material && INTERSECTED.material.emissive) {
                             INTERSECTED.material.emissive.setHex(INTERSECTED.userData.originalEmissive);
                        }
                    }
                    INTERSECTED = null;
                }
            }

            renderer.render(scene, camera);
        }

        // Start the animation on window load.
        window.onload = function () {
            init();
            animate();
        };
    </script>
</body>
</html>
