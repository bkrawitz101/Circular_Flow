<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spirit Well Ranch 3D Flow</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background for a futuristic feel */
            color: #e2e8f0; /* Light text color */
        }
        #info-panel {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: rgba(17, 24, 39, 0.9); /* Darker semi-transparent background */
            padding: 1rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            z-index: 100;
            max-width: 350px; /* Increased max-width for more content */
            font-size: 0.875rem;
            line-height: 1.5;
            border: 1px solid rgba(55, 65, 81, 0.5);
            display: none; /* Hidden by default */
            max-height: 90vh; /* Limit height for scrollability on small screens */
            overflow-y: auto; /* Enable scrolling for long content */
        }
        #info-panel h3 {
            font-weight: 700;
            font-size: 1.25rem; /* Slightly larger title */
            margin-bottom: 0.75rem;
            color: #93c5fd; /* Light blue for title */
        }
        #info-panel h4 {
            font-weight: 600;
            font-size: 1rem;
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
            color: #a7f3d0; /* Light green for subheadings */
        }
        #info-panel p, #info-panel ul {
            margin-bottom: 0.5rem;
        }
        #info-panel ul {
            list-style: disc;
            margin-left: 1.25rem;
            padding-left: 0;
        }
        #info-panel .close-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            color: #cbd5e1;
            font-size: 1.25rem;
            cursor: pointer;
            transition: color 0.2s;
        }
        #info-panel .close-button:hover {
            color: #f87171; /* Red on hover */
        }
        .nav-buttons-container {
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap */
            gap: 0.5rem; /* Space between buttons */
        }
        .nav-button {
            background-color: #10b981; /* Emerald green */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
            flex-grow: 1; /* Allow buttons to grow */
            min-width: 120px; /* Minimum width for buttons */
        }
        .nav-button:hover {
            background-color: #059669; /* Darker green on hover */
            transform: translateY(-1px);
        }
        .nav-button.home {
            background-color: #3b82f6; /* Blue for home button */
        }
        .nav-button.home:hover {
            background-color: #2563eb; /* Darker blue */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Mobile-specific styles for info panel */
        @media (max-width: 768px) {
            #info-panel {
                /* Remove full screen properties, let it size based on content and max-width/height */
                top: 1rem;   /* Keep top/left offset for mobile as well */
                left: 1rem;
                width: auto; /* Let content determine width */
                height: auto; /* Let content determine height */
                border-radius: 0.75rem; /* Revert to rounded corners */
                max-width: calc(100vw - 2rem); /* Constrain width to screen minus margins */
                max-height: calc(100vh - 2rem); /* Constrain height to screen minus margins */
            }
        }

        .overlay-button {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(59, 130, 246, 0.9); /* Tailwind blue-500 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: background-color 0.2s, transform 0.1s;
            z-index: 90; /* Below info panel but above canvas */
        }
        .overlay-button:hover {
            background-color: rgba(37, 99, 235, 0.9); /* Darker blue on hover */
            transform: translateX(-50%) translateY(-2px);
        }

        /* Adjust mobile button positioning */
        @media (max-width: 768px) {
            .overlay-button {
                bottom: 1rem; /* Slightly lower on mobile */
                font-size: 0.85rem;
                padding: 0.6rem 1rem;
                max-width: calc(100vw - 2rem); /* Prevent button from overflowing */
                white-space: normal; /* Allow text to wrap */
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div id="info-panel" class="rounded-xl p-4 shadow-lg">
        <button class="close-button" onclick="hideInfoPanel();">&times;</button>
        <h3 id="info-title"></h3>
        <p id="info-description"></p>
        <div id="info-details">
            </div>
        <div id="nav-buttons" class="nav-buttons-container">
            </div>
    </div>

    <button id="zoomOutButton" class="overlay-button">Start Experience</button>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script>
        // Global variables for Three.js scene
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let INTERSECTED; // To store the currently hovered object
        const nodesMap = new Map(); // Map to store Three.js objects by their data ID
        const particleSystems = []; // To store particle systems for animation (for all nodes)
        let earthAtmosphereParticles; // Specific for Earth atmosphere particles
        let centralEarthSphere; // Reference to the central Earth sphere

        // Data structure representing the nodes and their connections
        const flowData = [
            { id: 'waste-upcycle-hub', title: 'Waste Upcycle Hub', description: 'The central sorting and routing center for all incoming waste streams, acting as the primary intake and distribution point for all materials entering the closed-loop system.',
              inputs: ['Residential & Business Recyclables (plastic, glass, metal, paper, cardboard)', 'Food Waste (BriarPatch Co-op, on-site culinary, restaurant partners)', 'Butcher Trim (fat-heavy, frozen)', 'Used Cooking Oil from local restaurants', 'Agricultural Waste (stalks, leaves, biomass)'],
              outputs: ['Streamlined inputs for downstream systems', 'Categorized byproduct data for tracking'],
              connections: ['tallow-system', 'soil-program', 'soldier-fly-farm', 'biodiesel-production', 'mushroom-cultivation', 'artist-studio'], // Added connections
              feedsInto: [{id: 'tallow-system', label: 'Tallow System'}, {id: 'soil-program', label: 'Soil Program'}, {id: 'soldier-fly-farm', label: 'Soldier Fly Farm'}, {id: 'biodiesel-production', label: 'Biodiesel Plant'}, {id: 'mushroom-cultivation', label: 'Mushroom Farm'}, {id: 'artist-studio', label: 'Art/Design Studio'}],
              type: 'core',
              geometryType: 'box', // Custom geometry
              materialOptions: { color: 0x6B7280 } // Dark grey
            },

            { id: 'farm-animal-program', title: 'Farm Animal Rescue & Meat', description: 'Provides ethical care for rescued farm animals (pigs, goats, poultry), integrating them into the regenerative system for feed conversion and byproduct generation.',
              inputs: ['Rescued farm animals', 'Food waste (BriarPatch, on-site) for animal feed', 'Donations and sponsorships'],
              outputs: ['Ethically sourced meat (resale)', 'Animal fats (for tallow)', 'Bones/offal', 'Manure'],
              connections: ['tallow-system', 'soil-program', 'biodiesel-production'], // Added connections
              feedsInto: [{id: 'tallow-system', label: 'Tallow System'}, {id: 'soil-program', label: 'Soil Program'}, {id: 'biodiesel-production', label: 'Biodiesel (if excess fat)'}],
              type: 'biological',
              geometryType: 'cone', // Custom geometry (pyramid-like)
              materialOptions: { color: 0x8B4513 } // Saddle Brown
            },

            { id: 'soldier-fly-farm', title: 'Black Soldier Fly Farm', description: 'Converts organic waste into high-protein animal feed and organic fertilizer (frass) using black soldier fly larvae.',
              inputs: ['Food waste', 'Organic kitchen scraps', 'Cardboard mulch (bedding)', 'Byproduct tallow scraps (minimal)'],
              outputs: ['Protein-rich feed for animals', 'Frass (organic fertilizer)'],
              connections: ['farm-animal-program', 'soil-program'], // Added connections
              feedsInto: [{id: 'farm-animal-program', label: 'Animal Feed Program'}, {id: 'soil-program', label: 'Soil Program'}],
              type: 'biological' }, // Default sphere, type color

            { id: 'soil-program', title: 'Soil Program', description: 'The foundation of growth, creating nutrient-rich soil amendments through composting, vermiculture, and biochar activation.',
              inputs: ['Manure (animal rescue)', 'Food scraps (kitchen, BriarPatch)', 'Cardboard (from recyclables)', 'Spent mushroom substrate', 'Garden/agricultural trimmings', 'Black Soldier Fly frass', 'Biochar from pyrolysis'],
              outputs: ['Premium compost & worm castings', 'Biochar-rich soil blends', 'Mulch'],
              connections: ['herb-veg-gardens', 'mushroom-cultivation', 'soil-program'], // Added connections
              feedsInto: [{id: 'herb-veg-gardens', label: 'Herb & Vegetable Gardens'}, {id: 'mushroom-cultivation', label: 'Mushroom Substrate'}, {id: 'soil-program', label: 'Permaculture landscaping'}], // Self-referencing for landscaping
              type: 'biological',
              materialOptions: { color: 0x5D4037 } // Darker Earth Brown
            },

            { id: 'herb-veg-gardens', title: 'Herb & Vegetable Gardens', description: 'Cultivates a variety of herbs for skincare and medicine, and vegetables for culinary use, following permaculture principles.',
              inputs: ['Compost and biochar soil (from Soil Program)', 'Rainwater & greywater (future system)', 'Seeds & cuttings'],
              outputs: ['Herbs for skincare & medicine', 'Vegetables for culinary use'],
              connections: ['skincare-line', 'culinary-retreat-programs', 'soil-program'], // Added connections
              feedsInto: [{id: 'skincare-line', label: 'Skincare Line'}, {id: 'culinary-retreat-programs', label: 'Culinary & Retreat Programs'}, {id: 'soil-program', label: 'Soil Program (trimmings)'}],
              type: 'biological' }, // Default sphere, type color

            { id: 'mushroom-cultivation', title: 'Mushroom Cultivation', description: 'Grows gourmet mushrooms in climate-controlled environments, utilizing agricultural byproducts as substrate.',
              inputs: ['Shredded hemp stalks', 'Sawdust, cardboard, coffee grounds', 'Climate-controlled trailer (biomass heated)'],
              outputs: ['Gourmet mushrooms', 'Spent substrate for soil'],
              connections: ['culinary-retreat-programs', 'soil-program'], // Added connections
              feedsInto: [{id: 'culinary-retreat-programs', label: 'Culinary Program'}, {id: 'soil-program', label: 'Soil Program'}],
              type: 'biological' }, // Default sphere, type color

            { id: 'tallow-system', title: 'Tallow System', description: 'Renders animal fats into refined tallow for the skincare line and high-protein animal feed, ensuring no part of the animal goes to waste.',
              inputs: ['Butcher trim from BriarPatch (frozen fat & meat)', 'Fat from rescued animals'],
              outputs: ['Refined tallow', 'Boiled meat (high-protein animal feed)'],
              connections: ['skincare-line', 'biodiesel-production', 'farm-animal-program'], // Added connections
              feedsInto: [{id: 'skincare-line', label: 'Skincare Product Line'}, {id: 'biodiesel-production', label: 'Biodiesel System (optional secondary input)'}, {id: 'farm-animal-program', label: 'Animal Feed System'}],
              type: 'product' }, // Default sphere, type color

            { id: 'skincare-line', title: 'Spirit Well Skincare', description: 'Produces a line of natural, small-batch skincare products, embodying the ranch\'s regenerative ethos.',
              inputs: ['Refined tallow (from Tallow System)', 'Herbs (from on-site gardens)', 'Beeswax (future beekeeping)', 'Recycled jars/glass (from Artist Studio)'],
              outputs: ['Skincare products for sale (local, online)', 'Brand presence tied to regenerative ethos'],
              connections: ['retail-sales', 'campground-tourism'], // Added connections
              feedsInto: [{id: 'retail-sales', label: 'Retail Loop (with BriarPatch)'}, {id: 'campground-tourism', label: 'Workshops and educational demos'}],
              type: 'product' }, // Default sphere, type color

            { id: 'biodiesel-production', title: 'Biodiesel Production', description: 'Converts used cooking oils and excess animal fats into clean-burning biodiesel for ranch vehicles and generators.',
              inputs: ['Used cooking oil', 'Tallow (optional excess)', 'Methanol, Lye'],
              outputs: ['Biodiesel (for ranch vehicles, generators)', 'Glycerin (for soap, compost)'],
              connections: ['ranch-operations', 'soil-program'], // Added connections
              feedsInto: [{id: 'ranch-operations', label: 'Fuel for Ranch Operations'}, {id: 'soil-program', label: 'Soil Program (Glycerin)'}],
              type: 'resource',
              materialOptions: { color: 0xFFD700, emissive: 0xFFD700, emissiveIntensity: 0.5 }, // Gold glowing
              hasParticles: true // Add particles
            },

            { id: 'artist-studio', title: 'Artist Residency & Studio', description: 'A creative hub where local and visiting artists transform inorganic recyclables and found objects into art and functional items.',
              inputs: ['Clean metal, plastic, glass (from Recycle Hub)', 'Wood scraps, found objects', 'Local and visiting artists'],
              outputs: ['Large-scale art installations', 'Upcycled functional art', 'Circular packaging solutions'],
              connections: ['skincare-line', 'campground-tourism'], // Added connections
              feedsInto: [{id: 'skincare-line', label: 'Skincare Line (jars/branding)'}, {id: 'campground-tourism', label: 'Campground Decor / Sculpture Park'}],
              type: 'community' }, // Default sphere, type color

            { id: 'campground-tourism', title: 'Campground + Sculpture Park', description: 'A unique destination combining eco-cabins, outdoor exhibits, and educational events to promote regenerative tourism and community engagement.',
              inputs: ['Artist installations', 'Upcycled materials', 'Natural building elements'],
              outputs: ['Revenue from eco-tourism', 'Educational awareness', 'Community engagement'],
              connections: ['education-loop', 'artist-studio', 'fundraising'], // Added connections
              feedsInto: [{id: 'education-loop', label: 'Education Loop'}, {id: 'artist-studio', label: 'Artist Residencies'}, {id: 'fundraising', label: 'Fundraising and Grants'}],
              type: 'community' }, // Default sphere, type color

            // External nodes for clarity (no direct connections from them in this flow)
            { id: 'culinary-retreat-programs', title: 'Culinary & Retreat Programs', description: 'On-site culinary experiences and retreat offerings that utilize fresh produce from the gardens.', inputs: [], outputs: [], connections: [], feedsInto: [], type: 'external' },
            { id: 'retail-sales', title: 'Retail Sales', description: 'Channels for selling Spirit Well Ranch products, including local markets and online stores.', inputs: [], outputs: [], connections: [], feedsInto: [], type: 'external' },
            { id: 'ranch-operations', title: 'Ranch Operations', description: 'The daily functioning and energy consumption of the ranch, powered by sustainable energy sources like biodiesel.', inputs: [], outputs: [], connections: [], feedsInto: [], type: 'external' },
            { id: 'education-loop', title: 'Education Loop', description: 'Ongoing learning and knowledge sharing within the system, fostering a deeper understanding of regenerative practices.', inputs: [], outputs: [], connections: [], feedsInto: [], type: 'external',
              materialOptions: { color: 0xADD8E6, emissive: 0xADD8E6, emissiveIntensity: 0.3 } // Light blue glowing
            },
            { id: 'fundraising', title: 'Fundraising & Grants', description: 'Support mechanisms for the ranch\'s initiatives, enabling expansion and continued regenerative efforts.', inputs: [], outputs: [], connections: [], feedsInto: [], type: 'external' },
        ];

        // Mapping node types to colors (hexadecimal for Three.js) - primarily for default spheres
        const nodeTypeColors = {
            'core': 0xFDE047,      // Tailwind yellow-400
            'biological': 0x6EE7B7, // Tailwind emerald-300
            'product': 0x93C5FD,   // Tailwind blue-300
            'resource': 0xFCA5A5,  // Tailwind red-300
            'community': 0xD8B4FE, // Tailwind purple-300
            'external': 0x9CA3AF   // Tailwind gray-400
        };

        // Coordinates for 12450 Lime Kiln Road, Grass Valley, CA 95949
        const GRASS_VALLEY_LAT = 39.224151;
        const GRASS_VALLEY_LON = -121.036662;
        const EARTH_RADIUS_GLOBAL = 15; // Consistent Earth radius
        const EARTH_START_ZOOM_DISTANCE = 0.5; // Very close to the surface for initial view

        // Initial camera position and target for the map point (will be set after Earth creation)
        let INITIAL_MAP_CAMERA_POSITION;
        let INITIAL_MAP_CONTROLS_TARGET;

        // Define the full system view camera position and target
        const FULL_SYSTEM_VIEW_CAMERA_POSITION = new THREE.Vector3(0, 0, 100);
        const FULL_SYSTEM_VIEW_CONTROLS_TARGET = new THREE.Vector3(0, 0, 0);

        // Initialize the Three.js scene
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            // Load background image
            const textureLoader = new THREE.TextureLoader();
            const imagePath = './images/regeneration_background.png'; // Path to the user's image

            console.log(`Attempting to load background image from: ${imagePath}`); // Log the path being attempted

            textureLoader.load(
                imagePath,
                function(texture) {
                    scene.background = texture;
                    console.log(`Successfully loaded background image from: ${imagePath}`);
                },
                undefined, // onProgress callback
                function(err) {
                    // Log the full error object for better debugging
                    console.error(`An error occurred loading the background texture from "${imagePath}":`, err);
                    // Fallback to a reliable placeholder if the user's image fails to load
                    textureLoader.load(
                        'https://placehold.co/1920x1080/0d1117/e2e8f0?text=Regenerative+Background+Fallback',
                        function(fallbackTexture) {
                            scene.background = fallbackTexture;
                            console.log('Successfully loaded fallback background image.');
                        },
                        undefined,
                        function(fallbackErr) {
                            console.error('An error occurred loading the fallback background texture:', fallbackErr);
                            scene.background = new THREE.Color(0x0d1117); // Final fallback to solid dark color
                            console.log('Falling back to solid background color.');
                        }
                    );
                }
            );


            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Camera position and target will be set after Earth sphere creation

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // OrbitControls for camera interaction (drag to rotate, scroll to zoom)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enabled = false; // Initially disabled, will be enabled by button click
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            // minDistance/maxDistance will be set in createCentralEarthSphere

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            // Raycaster for mouse interaction (hover and click)
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Create nodes and connections
            createNodesAndConnections();
            createCentralEarthSphere(); // Create the new central Earth sphere

            // Event listeners for window resize, mouse interaction, and TOUCH interaction
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('click', onClick, false);
            window.addEventListener('touchend', onTouchEnd, false); // Add touch event listener for mobile devices

            // Set up the "Start Experience" button
            const zoomOutButton = document.getElementById('zoomOutButton');
            zoomOutButton.innerText = 'Circular Regenerative Systems of Spirit Well Ranch'; // Change button text
            zoomOutButton.style.display = 'block'; // Ensure it's visible initially

            zoomOutButton.addEventListener('click', () => {
                zoomToFullSystemView();
                zoomOutButton.style.display = 'none'; // Hide button after clicking
            });
            zoomOutButton.addEventListener('touchend', (e) => {
                // Ensure the button's own event is handled and not propagated to the canvas/window
                e.preventDefault();
                e.stopPropagation();
                zoomToFullSystemView();
                zoomOutButton.style.display = 'none'; // Hide button after clicking
            }, { passive: false }); // passive: false is crucial for preventDefault on touch events
        }

        // Function to convert Lat/Lon to Three.js Cartesian coordinates (Y-up)
        function latLonToCartesian(lat, lon, radius) {
            // Convert latitude and longitude to radians
            const latRad = lat * (Math.PI / 180);
            const lonRad = -lon * (Math.PI / 180); // Negative longitude for correct East/West

            // Spherical to Cartesian conversion
            const x = radius * Math.cos(latRad) * Math.sin(lonRad);
            const y = radius * Math.sin(latRad);
            const z = radius * Math.cos(latRad) * Math.cos(lonRad);

            return new THREE.Vector3(x, y, z);
        }

        // Function to create a text sprite
        function createTextSprite(message, color = '#FFFFFF', fontSize = 24) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const font = `${fontSize}px Inter`; // Use Inter font
            context.font = font;

            // Measure text to set canvas size
            const metrics = context.measureText(message);
            const textWidth = metrics.width;
            const textHeight = fontSize * 1.2; // Approximate height with some padding

            canvas.width = textWidth + 10; // Add padding
            canvas.height = textHeight + 10; // Add padding

            context.font = font;
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(message, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true; // Important for dynamic textures

            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);

            // Scale sprite based on text dimensions to maintain aspect ratio
            sprite.scale.set(canvas.width * 0.1, canvas.height * 0.1, 1); // Adjust scale factor as needed

            return sprite;
        }

        // Function to create simple particle system for a node
        function createParticleSystem(node) {
            const particleCount = 100;
            const particles = new THREE.BufferGeometry();
            const positions = [];
            const particleSize = 0.5;

            for (let i = 0; i < particleCount; i++) {
                // Random position around the node
                const x = (Math.random() - 0.5) * 10;
                const y = (Math.random() - 0.5) * 10;
                const z = (Math.random() - 0.5) * 10;
                positions.push(x, y, z);
            }

            particles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const particleMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF, // White particles
                size: particleSize,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending // For glowing effect
            });

            const particleSystem = new THREE.Points(particles, particleMaterial);
            node.add(particleSystem); // Add particles as a child of the node
            particleSystems.push(particleSystem); // Store for animation
            return particleSystem;
        }

        // Function to create the central Earth sphere with particles
        function createCentralEarthSphere() {
            const earthRadius = EARTH_RADIUS_GLOBAL; // Use global constant
            const earthSegments = 64; // High resolution for Earth

            // Earth Geometry and Material
            const earthGeometry = new THREE.SphereGeometry(earthRadius, earthSegments, earthSegments);
            const textureLoader = new THREE.TextureLoader();

            // Load Earth texture
            textureLoader.load(
                'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg', // High-res Earth texture
                function(earthTexture) {
                    const earthMaterial = new THREE.MeshPhongMaterial({
                        map: earthTexture,
                        specular: 0x333333,
                        shininess: 15
                    });
                    centralEarthSphere = new THREE.Mesh(earthGeometry, earthMaterial); // Assign to global variable
                    centralEarthSphere.position.set(0, 0, 0); // Center of the scene
                    scene.add(centralEarthSphere);

                    // Add atmospheric particles around Earth
                    const atmosphereParticleCount = 500;
                    const atmosphereParticles = new THREE.BufferGeometry();
                    const atmospherePositions = [];
                    const atmosphereColors = [];
                    const atmosphereParticleSize = 0.8;

                    for (let i = 0; i < atmosphereParticleCount; i++) {
                        // Position particles slightly outside the Earth sphere
                        const radiusOffset = earthRadius + (Math.random() * 5); // Particles 0 to 5 units outside
                        const phi = Math.acos(-1 + (2 * i) / atmosphereParticleCount);
                        const theta = Math.sqrt(atmosphereParticleCount * Math.PI) * phi;

                        const x = radiusOffset * Math.cos(theta) * Math.sin(phi);
                        const y = radiusOffset * Math.sin(theta) * Math.sin(phi);
                        const z = radiusOffset * Math.cos(phi);
                        atmospherePositions.push(x, y, z);

                        // Random blueish/white color for atmosphere
                        const color = new THREE.Color();
                        color.setHSL(0.6 + Math.random() * 0.1, 0.5 + Math.random() * 0.5, 0.7 + Math.random() * 0.3); // HSL for blueish white
                        atmosphereColors.push(color.r, color.g, color.b);
                    }

                    atmosphereParticles.setAttribute('position', new THREE.Float32BufferAttribute(atmospherePositions, 3));
                    atmosphereParticles.setAttribute('color', new THREE.Float32BufferAttribute(atmosphereColors, 3));

                    const atmosphereMaterial = new THREE.PointsMaterial({
                        size: atmosphereParticleSize,
                        vertexColors: true, // Use colors from geometry
                        transparent: true,
                        opacity: 0.8,
                        blending: THREE.AdditiveBlending // For glowing effect
                    });

                    earthAtmosphereParticles = new THREE.Points(atmosphereParticles, atmosphereMaterial);
                    scene.add(earthAtmosphereParticles);

                    // --- Set Initial Camera Position After Earth is Loaded ---
                    const mapPointOnEarth = latLonToCartesian(GRASS_VALLEY_LAT, GRASS_VALLEY_LON, earthRadius);
                    // Camera position is offset from the map point to look at it
                    INITIAL_MAP_CAMERA_POSITION = mapPointOnEarth.clone().normalize().multiplyScalar(earthRadius + EARTH_START_ZOOM_DISTANCE);
                    INITIAL_MAP_CONTROLS_TARGET = mapPointOnEarth.clone();

                    camera.position.copy(INITIAL_MAP_CAMERA_POSITION);
                    controls.target.copy(INITIAL_MAP_CONTROLS_TARGET);
                    controls.minDistance = earthRadius + 0.1; // Allow very close zoom
                    controls.maxDistance = 200; // Max zoom out distance
                    controls.update();
                },
                undefined, // onProgress
                function(err) {
                    console.error('An error occurred loading the Earth texture:', err);
                    // Fallback to a plain blue sphere if texture fails
                    const fallbackMaterial = new THREE.MeshPhongMaterial({ color: 0x0000FF });
                    centralEarthSphere = new THREE.Mesh(earthGeometry, fallbackMaterial); // Assign to global variable
                    centralEarthSphere.position.set(0, 0, 0);
                    scene.add(centralEarthSphere);

                     // --- Set Initial Camera Position Even if Earth Texture Fails ---
                    const mapPointOnEarth = latLonToCartesian(GRASS_VALLEY_LAT, GRASS_VALLEY_LON, earthRadius);
                    INITIAL_MAP_CAMERA_POSITION = mapPointOnEarth.clone().normalize().multiplyScalar(earthRadius + EARTH_START_ZOOM_DISTANCE);
                    INITIAL_MAP_CONTROLS_TARGET = mapPointOnEarth.clone();

                    camera.position.copy(INITIAL_MAP_CAMERA_POSITION);
                    controls.target.copy(INITIAL_MAP_CONTROLS_TARGET);
                    controls.minDistance = earthRadius + 0.1; // Allow very close zoom
                    controls.maxDistance = 200; // Max zoom out distance
                    controls.update();
                }
            );
        }


        // Function to create 3D nodes and connections
        function createNodesAndConnections() {
            const numNodes = flowData.length;
            const orbitRadius = 40; // Increased radius for nodes to orbit the new Earth sphere
            const nodeSize = 3; // Size of each node sphere
            const labelOffset = nodeSize + 2; // Offset for the label above the node

            // Create nodes
            flowData.forEach((nodeData, i) => {
                let geometry;
                // Choose geometry based on nodeData.geometryType
                switch (nodeData.geometryType) {
                    case 'box':
                        geometry = new THREE.BoxGeometry(nodeSize * 2, nodeSize * 2, nodeSize * 2); // Larger box for visual distinction
                        break;
                    case 'cone': // For pyramid-like shape
                        geometry = new THREE.ConeGeometry(nodeSize * 1.5, nodeSize * 3, 32); // Radius, Height, Segments
                        break;
                    case 'sphere':
                    default:
                        geometry = new THREE.SphereGeometry(nodeSize, 64, 64); // Increased segments for smoother geometry
                        break;
                }

                // Choose material based on nodeData.materialOptions or default type color
                const materialOptions = nodeData.materialOptions || {};
                const material = new THREE.MeshPhongMaterial({
                    color: materialOptions.color || nodeTypeColors[nodeData.type] || 0xffffff,
                    emissive: materialOptions.emissive || 0x000000,
                    emissiveIntensity: materialOptions.emissiveIntensity || 0,
                    specular: materialOptions.specular || 0x111111,
                    shininess: materialOptions.shininess || 30
                });

                const node = new THREE.Mesh(geometry, material);
                // Position nodes in a circle on the X-Y plane around the central Earth
                const angle = (i / numNodes) * Math.PI * 2; // Distribute evenly around a circle

                const x = orbitRadius * Math.cos(angle);
                const y = orbitRadius * Math.sin(angle);
                const z = 0; // Keep z-coordinate constant for a flat circular arrangement

                node.position.set(x, y, z);
                node.userData = { ...nodeData }; // Store all data for interaction
                scene.add(node);
                nodesMap.set(nodeData.id, node); // Store the Three.js object

                // Create and attach text label
                const labelSprite = createTextSprite(nodeData.title, '#E2E8F0', 20); // Light text color for labels
                labelSprite.position.set(x, y + labelOffset, z); // Position above the node
                scene.add(labelSprite);

                // Add particles if specified for this node
                if (nodeData.hasParticles) {
                    createParticleSystem(node);
                }
            });

            // Create connections (lines)
            flowData.forEach(sourceNodeData => {
                const sourceNode = nodesMap.get(sourceNodeData.id);
                if (!sourceNode) return;

                // Ensure connections array exists and is an array before iterating
                if (sourceNodeData.connections && Array.isArray(sourceNodeData.connections)) {
                    sourceNodeData.connections.forEach(targetId => {
                        const targetNode = nodesMap.get(targetId);
                        if (!targetNode) {
                            console.warn(`Target node with ID ${targetId} not found for connection from ${sourceNodeData.id}`);
                            return;
                        }

                        const material = new THREE.LineBasicMaterial({ color: 0x34d399, linewidth: 1 }); // Emerald green line
                        const points = [];
                        points.push(sourceNode.position);
                        points.push(targetNode.position);
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(geometry, material);
                        scene.add(line);
                    });
                }
            });
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Handle mouse movement for hover effect
        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        // Internal function for click/touch logic, called by both onClick and onTouchEnd
        function onClickInternal() {
            // Only allow clicks if controls are enabled (i.e., not in the middle of a camera animation or panel is open)
            if (!controls.enabled) return; // This correctly prevents clicks on the 3D scene when controls are disabled

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {
                const clickedNode = intersects.find(obj => obj.object.userData && obj.object.userData.id);
                if (clickedNode) {
                    zoomToNode(clickedNode.object.userData.id);
                }
            }
        }

        // Handle mouse click for desktop
        function onClick(event) {
             // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            onClickInternal(); // Call the shared internal logic
        }

        // Function to handle touch end event for 'clicking' on mobile
        function onTouchEnd(event) {
            // Check if the touch originated on an element within the info panel
            const infoPanel = document.getElementById('info-panel');
            const zoomOutButton = document.getElementById('zoomOutButton'); // Get reference to the button

            let isTouchOnUI = false;
            let targetElement = event.target;
            while (targetElement) {
                if (targetElement === infoPanel || targetElement === zoomOutButton) { // Check both panel and button
                    isTouchOnUI = true;
                    break;
                }
                targetElement = targetElement.parentNode;
            }

            // If touch is on a UI element, let its own event handlers take over.
            // Do NOT preventDefault or stopPropagation on the window/document level.
            if (isTouchOnUI) {
                return;
            } else {
                // If touch is outside any UI element (i.e., on the canvas), prevent default behavior
                event.preventDefault();
                event.stopPropagation(); // Also stop propagation to be safe
                // And then process the 3D scene click
                if (event.changedTouches.length > 0) {
                    const touch = event.changedTouches[0];
                    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                    onClickInternal();
                }
            }
        }


        // Function to animate camera to a target position and look at a target point
        function animateCamera(targetPosition, targetLookAt, duration = 1) {
            controls.enabled = false; // Disable controls during animation

            gsap.to(camera.position, {
                duration: duration,
                x: targetPosition.x,
                y: targetPosition.y,
                z: targetPosition.z,
                ease: "power2.inOut",
                onUpdate: function() {
                    // Update controls.target during camera movement to keep looking at the target
                    controls.target.lerp(targetLookAt, this.progress());
                    controls.update();
                },
                onComplete: function() {
                    // Only re-enable controls if the info panel is NOT currently visible
                    const infoPanel = document.getElementById('info-panel');
                    if (infoPanel.style.display !== 'block') {
                        controls.enabled = true;
                    }
                    controls.target.copy(targetLookAt); // Ensure target is exactly set
                    controls.update();
                }
            });
        }

        // Function to zoom to a specific node
        function zoomToNode(nodeId) {
            const node = nodesMap.get(nodeId);
            if (!node) {
                console.error(`Node with ID ${nodeId} not found.`);
                return;
            }

            const nodePosition = node.position;
            // Calculate a camera position slightly in front of the node
            const zoomDistance = 15; // How far the camera should be from the node
            const targetPosition = new THREE.Vector3().copy(nodePosition).add(new THREE.Vector3(0, 0, zoomDistance));

            animateCamera(targetPosition, nodePosition, 1.5); // Animate over 1.5 seconds
            displayNodeInfo(node.userData); // Display detailed info for the clicked node
        }

        // Function to zoom to the full system view
        function zoomToFullSystemView() {
            animateCamera(FULL_SYSTEM_VIEW_CAMERA_POSITION, FULL_SYSTEM_VIEW_CONTROLS_TARGET, 2); // Longer animation for initial zoom out
            hideInfoPanel();
        }

        // Function to display detailed node information
        function displayNodeInfo(nodeData) {
            const infoPanel = document.getElementById('info-panel');
            document.getElementById('info-title').innerText = nodeData.title;
            document.getElementById('info-description').innerText = nodeData.description;

            const infoDetails = document.getElementById('info-details');
            infoDetails.innerHTML = ''; // Clear previous details

            // Add Inputs
            if (nodeData.inputs && nodeData.inputs.length > 0) {
                const inputsTitle = document.createElement('h4');
                inputsTitle.innerText = 'Inputs:';
                infoDetails.appendChild(inputsTitle);
                const inputsList = document.createElement('ul');
                nodeData.inputs.forEach(input => {
                    const li = document.createElement('li');
                    li.innerText = input;
                    inputsList.appendChild(li);
                });
                infoDetails.appendChild(inputsList);
            }

            // Add Outputs
            if (nodeData.outputs && nodeData.outputs.length > 0) {
                const outputsTitle = document.createElement('h4');
                outputsTitle.innerText = 'Outputs:';
                infoDetails.appendChild(outputsTitle);
                const outputsList = document.createElement('ul');
                nodeData.outputs.forEach(output => {
                    const li = document.createElement('li');
                    li.innerText = output;
                    outputsList.appendChild(li);
                });
                infoDetails.appendChild(outputsList);
            }

            // Add Feeds Into / Connected Systems
            const navButtonsContainer = document.getElementById('nav-buttons');
            navButtonsContainer.innerHTML = ''; // Clear previous buttons

            // Home Button
            const homeButton = document.createElement('button');
            homeButton.className = 'nav-button home';
            homeButton.innerText = 'Zoom Out to Home';
            homeButton.addEventListener('click', zoomToFullSystemView); // For desktop clicks
            homeButton.addEventListener('touchend', (e) => { // For mobile taps
                e.preventDefault(); // Stop default touch behavior (e.g., scrolling)
                e.stopPropagation(); // Stop event from bubbling up to canvas/window
                zoomToFullSystemView();
            }, { passive: false }); // crucial for preventDefault on touch events
            navButtonsContainer.appendChild(homeButton);

            if (nodeData.feedsInto && nodeData.feedsInto.length > 0) {
                const connectedTitle = document.createElement('h4');
                connectedTitle.innerText = 'Connected Systems:';
                infoDetails.appendChild(connectedTitle); // Add title inside info-details
                // Add connected system buttons
                nodeData.feedsInto.forEach(connection => {
                    const connectedButton = document.createElement('button');
                    connectedButton.className = 'nav-button';
                    connectedButton.innerText = `Go to ${connection.label}`;
                    connectedButton.addEventListener('click', () => zoomToNode(connection.id)); // For desktop clicks
                    connectedButton.addEventListener('touchend', (e) => { // For mobile taps
                        e.preventDefault(); // Stop default touch behavior
                        e.stopPropagation(); // Stop event from bubbling up
                        zoomToNode(connection.id);
                    }, { passive: false }); // crucial for preventDefault on touch events
                    navButtonsContainer.appendChild(connectedButton);
                });
            }

            infoPanel.style.display = 'block'; // Show the info panel
            // Disable controls when panel is open
            if (controls) {
                controls.enabled = false;
            }
        }

        // Function to hide the info panel
        function hideInfoPanel() {
            const infoPanel = document.getElementById('info-panel');
            infoPanel.style.display = 'none';
            // Re-enable controls when panel is closed
            if (controls) {
                controls.enabled = true;
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update controls (only if they are enabled)
            if (controls && controls.enabled) { // Only update if controls are enabled
                controls.update();
            }

            // Animate particles for the central Earth atmosphere
            if (earthAtmosphereParticles) {
                earthAtmosphereParticles.rotation.y += 0.001; // Slow rotation
                // Optional: subtle movement for a more organic feel
                const positions = earthAtmosphereParticles.geometry.attributes.position.array;
                const time = Date.now() * 0.0001;
                for (let i = 0; i < positions.length; i += 3) {
                    const originalX = positions[i];
                    const originalY = positions[i + 1];
                    const originalZ = positions[i + 2];
                    positions[i] = originalX + Math.sin(time + originalY * 0.1) * 0.1;
                    positions[i + 1] = originalY + Math.cos(time + originalZ * 0.1) * 0.1;
                    positions[i + 2] = originalZ + Math.sin(time + originalX * 0.1) * 0.1;
                }
                earthAtmosphereParticles.geometry.attributes.position.needsUpdate = true;
            }

            // Animate specific node particles if they exist
            particleSystems.forEach(ps => {
                if (ps.parent && ps.parent.visible) { // Only animate if parent node is visible
                    ps.rotation.y += 0.01;
                    ps.rotation.x += 0.005;
                    const positions = ps.geometry.attributes.position.array;
                    const time = Date.now() * 0.001;
                    for (let i = 0; i < positions.length; i += 3) {
                        const originalX = positions[i];
                        const originalY = positions[i + 1];
                        const originalZ = positions[i + 2];
                        positions[i] = originalX + Math.sin(time + originalY * 0.5) * 0.005;
                        positions[i + 1] = originalY + Math.cos(time + originalZ * 0.5) * 0.005;
                        positions[i + 2] = originalZ + Math.sin(time + originalX * 0.5) * 0.005;
                    }
                    ps.geometry.attributes.position.needsUpdate = true;
                }
            });


            // Raycasting for hover effect (only if controls are enabled)
            if (controls && controls.enabled) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children);

                if (intersects.length > 0) {
                    const hoveredNode = intersects.find(obj => obj.object.userData && obj.object.userData.id);

                    if (hoveredNode) {
                        if (INTERSECTED != hoveredNode.object) {
                            // Restore previous intersected object's color
                            if (INTERSECTED) {
                                INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
                            }
                            // Store current intersected object and change its color
                            INTERSECTED = hoveredNode.object;
                            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                            INTERSECTED.material.emissive.setHex(0x222222); // Subtle glow on hover
                        }
                    } else {
                        // No intersection or new object, restore previous
                        if (INTERSECTED) {
                            INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
                        }
                        INTERSECTED = null;
                    }
                } else {
                    // No intersection, restore previous
                    if (INTERSECTED) {
                        INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
                    }
                    INTERSECTED = null;
                }
            }

            renderer.render(scene, camera);
        }

        // Start the animation on window load.
        window.onload = function () {
            init();
            animate();
        };
    </script>
</body>
</html>
